# This file was generated based on ".graphqlconfig.yml". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with a globally unique `ID`."
interface Node {
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
}

type Audit implements Node {
    action: String
    createat: BigInt
    extrainfo: String
    id: String!
    ipaddress: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    sessionid: String
    userid: String
}

"A connection to a list of `Audit` values."
type AuditsConnection {
    "A list of edges which contains the `Audit` and cursor to aid in pagination."
    edges: [AuditsEdge!]!
    "A list of `Audit` objects."
    nodes: [Audit]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Audit` you could get from the connection."
    totalCount: Int!
}

"A `Audit` edge in the connection."
type AuditsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Audit` at the end of the edge."
    node: Audit
}

type Bot implements Node {
    createat: BigInt
    deleteat: BigInt
    description: String
    lasticonupdate: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    ownerid: String
    updateat: BigInt
    userid: String!
}

"A connection to a list of `Bot` values."
type BotsConnection {
    "A list of edges which contains the `Bot` and cursor to aid in pagination."
    edges: [BotsEdge!]!
    "A list of `Bot` objects."
    nodes: [Bot]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Bot` you could get from the connection."
    totalCount: Int!
}

"A `Bot` edge in the connection."
type BotsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Bot` at the end of the edge."
    node: Bot
}

type Channel implements Node {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    displayname: String
    extraupdateat: BigInt
    groupconstrained: Boolean
    header: String
    id: String!
    lastpostat: BigInt
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    purpose: String
    schemeid: String
    teamid: String
    totalmsgcount: BigInt
    type: String
    updateat: BigInt
}

type Channelmember implements Node {
    channelid: String!
    lastupdateat: BigInt
    lastviewedat: BigInt
    mentioncount: BigInt
    msgcount: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    notifyprops: String
    roles: String
    schemeadmin: Boolean
    schemeguest: Boolean
    schemeuser: Boolean
    "Reads a single `User` that is related to this `Channelmember`."
    userByUserid: User
    userid: String!
}

"A connection to a list of `Channelmemberhistory` values."
type ChannelmemberhistoriesConnection {
    "A list of edges which contains the `Channelmemberhistory` and cursor to aid in pagination."
    edges: [ChannelmemberhistoriesEdge!]!
    "A list of `Channelmemberhistory` objects."
    nodes: [Channelmemberhistory]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Channelmemberhistory` you could get from the connection."
    totalCount: Int!
}

"A `Channelmemberhistory` edge in the connection."
type ChannelmemberhistoriesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Channelmemberhistory` at the end of the edge."
    node: Channelmemberhistory
}

type Channelmemberhistory implements Node {
    channelid: String!
    jointime: BigInt!
    leavetime: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    userid: String!
}

"A connection to a list of `Channelmember` values."
type ChannelmembersConnection {
    "A list of edges which contains the `Channelmember` and cursor to aid in pagination."
    edges: [ChannelmembersEdge!]!
    "A list of `Channelmember` objects."
    nodes: [Channelmember]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Channelmember` you could get from the connection."
    totalCount: Int!
}

"A `Channelmember` edge in the connection."
type ChannelmembersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Channelmember` at the end of the edge."
    node: Channelmember
}

"A connection to a list of `Channel` values."
type ChannelsConnection {
    "A list of edges which contains the `Channel` and cursor to aid in pagination."
    edges: [ChannelsEdge!]!
    "A list of `Channel` objects."
    nodes: [Channel]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Channel` you could get from the connection."
    totalCount: Int!
}

"A `Channel` edge in the connection."
type ChannelsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Channel` at the end of the edge."
    node: Channel
}

"A connection to a list of `Clusterdiscovery` values."
type ClusterdiscoveriesConnection {
    "A list of edges which contains the `Clusterdiscovery` and cursor to aid in pagination."
    edges: [ClusterdiscoveriesEdge!]!
    "A list of `Clusterdiscovery` objects."
    nodes: [Clusterdiscovery]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Clusterdiscovery` you could get from the connection."
    totalCount: Int!
}

"A `Clusterdiscovery` edge in the connection."
type ClusterdiscoveriesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Clusterdiscovery` at the end of the edge."
    node: Clusterdiscovery
}

type Clusterdiscovery implements Node {
    clustername: String
    createat: BigInt
    gossipport: Int
    hostname: String
    id: String!
    lastpingat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    port: Int
    type: String
}

type Command implements Node {
    autocomplete: Boolean
    autocompletedesc: String
    autocompletehint: String
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String!
    method: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    teamid: String
    token: String
    trigger: String
    updateat: BigInt
    url: String
    username: String
}

"A connection to a list of `Command` values."
type CommandsConnection {
    "A list of edges which contains the `Command` and cursor to aid in pagination."
    edges: [CommandsEdge!]!
    "A list of `Command` objects."
    nodes: [Command]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Command` you could get from the connection."
    totalCount: Int!
}

"A `Command` edge in the connection."
type CommandsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Command` at the end of the edge."
    node: Command
}

type Commandwebhook implements Node {
    channelid: String
    commandid: String
    createat: BigInt
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    parentid: String
    rootid: String
    usecount: Int
    userid: String
}

"A connection to a list of `Commandwebhook` values."
type CommandwebhooksConnection {
    "A list of edges which contains the `Commandwebhook` and cursor to aid in pagination."
    edges: [CommandwebhooksEdge!]!
    "A list of `Commandwebhook` objects."
    nodes: [Commandwebhook]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Commandwebhook` you could get from the connection."
    totalCount: Int!
}

"A `Commandwebhook` edge in the connection."
type CommandwebhooksEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Commandwebhook` at the end of the edge."
    node: Commandwebhook
}

type Compliance implements Node {
    count: Int
    createat: BigInt
    desc: String
    emails: String
    endat: BigInt
    id: String!
    keywords: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    startat: BigInt
    status: String
    type: String
    userid: String
}

"A connection to a list of `Compliance` values."
type CompliancesConnection {
    "A list of edges which contains the `Compliance` and cursor to aid in pagination."
    edges: [CompliancesEdge!]!
    "A list of `Compliance` objects."
    nodes: [Compliance]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Compliance` you could get from the connection."
    totalCount: Int!
}

"A `Compliance` edge in the connection."
type CompliancesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Compliance` at the end of the edge."
    node: Compliance
}

"The output of our create `Audit` mutation."
type CreateAuditPayload {
    "The `Audit` that was created by this mutation."
    audit: Audit
    "An edge for our `Audit`. May be used by Relay 1."
    auditEdge(
        #The method to use when ordering `Audit`.
        orderBy: [AuditsOrderBy!] = [PRIMARY_KEY_ASC]
    ): AuditsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Bot` mutation."
type CreateBotPayload {
    "The `Bot` that was created by this mutation."
    bot: Bot
    "An edge for our `Bot`. May be used by Relay 1."
    botEdge(
        #The method to use when ordering `Bot`.
        orderBy: [BotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): BotsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Channel` mutation."
type CreateChannelPayload {
    "The `Channel` that was created by this mutation."
    channel: Channel
    "An edge for our `Channel`. May be used by Relay 1."
    channelEdge(
        #The method to use when ordering `Channel`.
        orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Channelmember` mutation."
type CreateChannelmemberPayload {
    "The `Channelmember` that was created by this mutation."
    channelmember: Channelmember
    "An edge for our `Channelmember`. May be used by Relay 1."
    channelmemberEdge(
        #The method to use when ordering `Channelmember`.
        orderBy: [ChannelmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmembersEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Channelmember`."
    userByUserid: User
}

"The output of our create `Channelmemberhistory` mutation."
type CreateChannelmemberhistoryPayload {
    "The `Channelmemberhistory` that was created by this mutation."
    channelmemberhistory: Channelmemberhistory
    "An edge for our `Channelmemberhistory`. May be used by Relay 1."
    channelmemberhistoryEdge(
        #The method to use when ordering `Channelmemberhistory`.
        orderBy: [ChannelmemberhistoriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmemberhistoriesEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Clusterdiscovery` mutation."
type CreateClusterdiscoveryPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Clusterdiscovery` that was created by this mutation."
    clusterdiscovery: Clusterdiscovery
    "An edge for our `Clusterdiscovery`. May be used by Relay 1."
    clusterdiscoveryEdge(
        #The method to use when ordering `Clusterdiscovery`.
        orderBy: [ClusterdiscoveriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClusterdiscoveriesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Command` mutation."
type CreateCommandPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Command` that was created by this mutation."
    command: Command
    "An edge for our `Command`. May be used by Relay 1."
    commandEdge(
        #The method to use when ordering `Command`.
        orderBy: [CommandsOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Commandwebhook` mutation."
type CreateCommandwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Commandwebhook` that was created by this mutation."
    commandwebhook: Commandwebhook
    "An edge for our `Commandwebhook`. May be used by Relay 1."
    commandwebhookEdge(
        #The method to use when ordering `Commandwebhook`.
        orderBy: [CommandwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Compliance` mutation."
type CreateCompliancePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Compliance` that was created by this mutation."
    compliance: Compliance
    "An edge for our `Compliance`. May be used by Relay 1."
    complianceEdge(
        #The method to use when ordering `Compliance`.
        orderBy: [CompliancesOrderBy!] = [PRIMARY_KEY_ASC]
    ): CompliancesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Emoji` mutation."
type CreateEmojiPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Emoji` that was created by this mutation."
    emoji: Emoji
    "An edge for our `Emoji`. May be used by Relay 1."
    emojiEdge(
        #The method to use when ordering `Emoji`.
        orderBy: [EmojisOrderBy!] = [PRIMARY_KEY_ASC]
    ): EmojisEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Fileinfo` mutation."
type CreateFileinfoPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Fileinfo` that was created by this mutation."
    fileinfo: Fileinfo
    "An edge for our `Fileinfo`. May be used by Relay 1."
    fileinfoEdge(
        #The method to use when ordering `Fileinfo`.
        orderBy: [FileinfosOrderBy!] = [PRIMARY_KEY_ASC]
    ): FileinfosEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Groupchannel` mutation."
type CreateGroupchannelPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Groupchannel` that was created by this mutation."
    groupchannel: Groupchannel
    "An edge for our `Groupchannel`. May be used by Relay 1."
    groupchannelEdge(
        #The method to use when ordering `Groupchannel`.
        orderBy: [GroupchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupchannelsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Groupmember` mutation."
type CreateGroupmemberPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Groupmember` that was created by this mutation."
    groupmember: Groupmember
    "An edge for our `Groupmember`. May be used by Relay 1."
    groupmemberEdge(
        #The method to use when ordering `Groupmember`.
        orderBy: [GroupmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupmembersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Groupteam` mutation."
type CreateGroupteamPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Groupteam` that was created by this mutation."
    groupteam: Groupteam
    "An edge for our `Groupteam`. May be used by Relay 1."
    groupteamEdge(
        #The method to use when ordering `Groupteam`.
        orderBy: [GroupteamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupteamsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Incomingwebhook` mutation."
type CreateIncomingwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Incomingwebhook` that was created by this mutation."
    incomingwebhook: Incomingwebhook
    "An edge for our `Incomingwebhook`. May be used by Relay 1."
    incomingwebhookEdge(
        #The method to use when ordering `Incomingwebhook`.
        orderBy: [IncomingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): IncomingwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Job` mutation."
type CreateJobPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Job` that was created by this mutation."
    job: Job
    "An edge for our `Job`. May be used by Relay 1."
    jobEdge(
        #The method to use when ordering `Job`.
        orderBy: [JobsOrderBy!] = [PRIMARY_KEY_ASC]
    ): JobsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `License` mutation."
type CreateLicensePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `License` that was created by this mutation."
    license: License
    "An edge for our `License`. May be used by Relay 1."
    licenseEdge(
        #The method to use when ordering `License`.
        orderBy: [LicensesOrderBy!] = [PRIMARY_KEY_ASC]
    ): LicensesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Linkmetadatum` mutation."
type CreateLinkmetadatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Linkmetadatum` that was created by this mutation."
    linkmetadatum: Linkmetadatum
    "An edge for our `Linkmetadatum`. May be used by Relay 1."
    linkmetadatumEdge(
        #The method to use when ordering `Linkmetadatum`.
        orderBy: [LinkmetadataOrderBy!] = [PRIMARY_KEY_ASC]
    ): LinkmetadataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Oauthaccessdatum` mutation."
type CreateOauthaccessdatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Oauthaccessdatum` that was created by this mutation."
    oauthaccessdatum: Oauthaccessdatum
    "An edge for our `Oauthaccessdatum`. May be used by Relay 1."
    oauthaccessdatumEdge(
        #The method to use when ordering `Oauthaccessdatum`.
        orderBy: [OauthaccessdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthaccessdataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Oauthapp` mutation."
type CreateOauthappPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Oauthapp` that was created by this mutation."
    oauthapp: Oauthapp
    "An edge for our `Oauthapp`. May be used by Relay 1."
    oauthappEdge(
        #The method to use when ordering `Oauthapp`.
        orderBy: [OauthappsOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthappsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Oauthauthdatum` mutation."
type CreateOauthauthdatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Oauthauthdatum` that was created by this mutation."
    oauthauthdatum: Oauthauthdatum
    "An edge for our `Oauthauthdatum`. May be used by Relay 1."
    oauthauthdatumEdge(
        #The method to use when ordering `Oauthauthdatum`.
        orderBy: [OauthauthdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthauthdataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Outgoingwebhook` mutation."
type CreateOutgoingwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Outgoingwebhook` that was created by this mutation."
    outgoingwebhook: Outgoingwebhook
    "An edge for our `Outgoingwebhook`. May be used by Relay 1."
    outgoingwebhookEdge(
        #The method to use when ordering `Outgoingwebhook`.
        orderBy: [OutgoingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): OutgoingwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Pluginkeyvaluestore` mutation."
type CreatePluginkeyvaluestorePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Pluginkeyvaluestore` that was created by this mutation."
    pluginkeyvaluestore: Pluginkeyvaluestore
    "An edge for our `Pluginkeyvaluestore`. May be used by Relay 1."
    pluginkeyvaluestoreEdge(
        #The method to use when ordering `Pluginkeyvaluestore`.
        orderBy: [PluginkeyvaluestoresOrderBy!] = [PRIMARY_KEY_ASC]
    ): PluginkeyvaluestoresEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Post` mutation."
type CreatePostPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Post` that was created by this mutation."
    post: Post
    "An edge for our `Post`. May be used by Relay 1."
    postEdge(
        #The method to use when ordering `Post`.
        orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PostsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Post`."
    user: User
}

"The output of our create `Preference` mutation."
type CreatePreferencePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Preference` that was created by this mutation."
    preference: Preference
    "An edge for our `Preference`. May be used by Relay 1."
    preferenceEdge(
        #The method to use when ordering `Preference`.
        orderBy: [PreferencesOrderBy!] = [PRIMARY_KEY_ASC]
    ): PreferencesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Publicchannel` mutation."
type CreatePublicchannelPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Publicchannel` that was created by this mutation."
    publicchannel: Publicchannel
    "An edge for our `Publicchannel`. May be used by Relay 1."
    publicchannelEdge(
        #The method to use when ordering `Publicchannel`.
        orderBy: [PublicchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PublicchannelsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `Reaction` mutation."
type CreateReactionPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Reaction` that was created by this mutation."
    reaction: Reaction
    "An edge for our `Reaction`. May be used by Relay 1."
    reactionEdge(
        #The method to use when ordering `Reaction`.
        orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ReactionsEdge
}

"The output of our create `Role` mutation."
type CreateRolePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Role` that was created by this mutation."
    role: Role
    "An edge for our `Role`. May be used by Relay 1."
    roleEdge(
        #The method to use when ordering `Role`.
        orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RolesEdge
}

"The output of our create `Scheme` mutation."
type CreateSchemePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Scheme` that was created by this mutation."
    scheme: Scheme
    "An edge for our `Scheme`. May be used by Relay 1."
    schemeEdge(
        #The method to use when ordering `Scheme`.
        orderBy: [SchemesOrderBy!] = [PRIMARY_KEY_ASC]
    ): SchemesEdge
}

"The output of our create `Session` mutation."
type CreateSessionPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Session` that was created by this mutation."
    session: Session
    "An edge for our `Session`. May be used by Relay 1."
    sessionEdge(
        #The method to use when ordering `Session`.
        orderBy: [SessionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SessionsEdge
}

"The output of our create `Status` mutation."
type CreateStatusPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Status` that was created by this mutation."
    status: Status
    "An edge for our `Status`. May be used by Relay 1."
    statusEdge(
        #The method to use when ordering `Status`.
        orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StatusesEdge
}

"The output of our create `System` mutation."
type CreateSystemPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `System` that was created by this mutation."
    system: System
    "An edge for our `System`. May be used by Relay 1."
    systemEdge(
        #The method to use when ordering `System`.
        orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SystemsEdge
}

"The output of our create `Team` mutation."
type CreateTeamPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Team` that was created by this mutation."
    team: Team
    "An edge for our `Team`. May be used by Relay 1."
    teamEdge(
        #The method to use when ordering `Team`.
        orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeamsEdge
}

"The output of our create `Teammember` mutation."
type CreateTeammemberPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Teammember` that was created by this mutation."
    teammember: Teammember
    "An edge for our `Teammember`. May be used by Relay 1."
    teammemberEdge(
        #The method to use when ordering `Teammember`.
        orderBy: [TeammembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeammembersEdge
}

"The output of our create `Termsofservice` mutation."
type CreateTermsofservicePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Termsofservice` that was created by this mutation."
    termsofservice: Termsofservice
    "An edge for our `Termsofservice`. May be used by Relay 1."
    termsofserviceEdge(
        #The method to use when ordering `Termsofservice`.
        orderBy: [TermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): TermsofservicesEdge
}

"The output of our create `Token` mutation."
type CreateTokenPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Token` that was created by this mutation."
    token: Token
    "An edge for our `Token`. May be used by Relay 1."
    tokenEdge(
        #The method to use when ordering `Token`.
        orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): TokensEdge
}

"The output of our create `User` mutation."
type CreateUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was created by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

"The output of our create `Useraccesstoken` mutation."
type CreateUseraccesstokenPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Useraccesstoken` that was created by this mutation."
    useraccesstoken: Useraccesstoken
    "An edge for our `Useraccesstoken`. May be used by Relay 1."
    useraccesstokenEdge(
        #The method to use when ordering `Useraccesstoken`.
        orderBy: [UseraccesstokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): UseraccesstokensEdge
}

"The output of our create `Usergroup` mutation."
type CreateUsergroupPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Usergroup` that was created by this mutation."
    usergroup: Usergroup
    "An edge for our `Usergroup`. May be used by Relay 1."
    usergroupEdge(
        #The method to use when ordering `Usergroup`.
        orderBy: [UsergroupsOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsergroupsEdge
}

"The output of our create `Usertermsofservice` mutation."
type CreateUsertermsofservicePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Usertermsofservice` that was created by this mutation."
    usertermsofservice: Usertermsofservice
    "An edge for our `Usertermsofservice`. May be used by Relay 1."
    usertermsofserviceEdge(
        #The method to use when ordering `Usertermsofservice`.
        orderBy: [UsertermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsertermsofservicesEdge
}

"The output of our delete `Audit` mutation."
type DeleteAuditPayload {
    "The `Audit` that was deleted by this mutation."
    audit: Audit
    "An edge for our `Audit`. May be used by Relay 1."
    auditEdge(
        #The method to use when ordering `Audit`.
        orderBy: [AuditsOrderBy!] = [PRIMARY_KEY_ASC]
    ): AuditsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedAuditNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Bot` mutation."
type DeleteBotPayload {
    "The `Bot` that was deleted by this mutation."
    bot: Bot
    "An edge for our `Bot`. May be used by Relay 1."
    botEdge(
        #The method to use when ordering `Bot`.
        orderBy: [BotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): BotsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedBotNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Channel` mutation."
type DeleteChannelPayload {
    "The `Channel` that was deleted by this mutation."
    channel: Channel
    "An edge for our `Channel`. May be used by Relay 1."
    channelEdge(
        #The method to use when ordering `Channel`.
        orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedChannelNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Channelmember` mutation."
type DeleteChannelmemberPayload {
    "The `Channelmember` that was deleted by this mutation."
    channelmember: Channelmember
    "An edge for our `Channelmember`. May be used by Relay 1."
    channelmemberEdge(
        #The method to use when ordering `Channelmember`.
        orderBy: [ChannelmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmembersEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedChannelmemberNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Channelmember`."
    userByUserid: User
}

"The output of our delete `Channelmemberhistory` mutation."
type DeleteChannelmemberhistoryPayload {
    "The `Channelmemberhistory` that was deleted by this mutation."
    channelmemberhistory: Channelmemberhistory
    "An edge for our `Channelmemberhistory`. May be used by Relay 1."
    channelmemberhistoryEdge(
        #The method to use when ordering `Channelmemberhistory`.
        orderBy: [ChannelmemberhistoriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmemberhistoriesEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedChannelmemberhistoryNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Clusterdiscovery` mutation."
type DeleteClusterdiscoveryPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Clusterdiscovery` that was deleted by this mutation."
    clusterdiscovery: Clusterdiscovery
    "An edge for our `Clusterdiscovery`. May be used by Relay 1."
    clusterdiscoveryEdge(
        #The method to use when ordering `Clusterdiscovery`.
        orderBy: [ClusterdiscoveriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClusterdiscoveriesEdge
    deletedClusterdiscoveryNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Command` mutation."
type DeleteCommandPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Command` that was deleted by this mutation."
    command: Command
    "An edge for our `Command`. May be used by Relay 1."
    commandEdge(
        #The method to use when ordering `Command`.
        orderBy: [CommandsOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandsEdge
    deletedCommandNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Commandwebhook` mutation."
type DeleteCommandwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Commandwebhook` that was deleted by this mutation."
    commandwebhook: Commandwebhook
    "An edge for our `Commandwebhook`. May be used by Relay 1."
    commandwebhookEdge(
        #The method to use when ordering `Commandwebhook`.
        orderBy: [CommandwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandwebhooksEdge
    deletedCommandwebhookNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Compliance` mutation."
type DeleteCompliancePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Compliance` that was deleted by this mutation."
    compliance: Compliance
    "An edge for our `Compliance`. May be used by Relay 1."
    complianceEdge(
        #The method to use when ordering `Compliance`.
        orderBy: [CompliancesOrderBy!] = [PRIMARY_KEY_ASC]
    ): CompliancesEdge
    deletedComplianceNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Emoji` mutation."
type DeleteEmojiPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedEmojiNodeId: ID
    "The `Emoji` that was deleted by this mutation."
    emoji: Emoji
    "An edge for our `Emoji`. May be used by Relay 1."
    emojiEdge(
        #The method to use when ordering `Emoji`.
        orderBy: [EmojisOrderBy!] = [PRIMARY_KEY_ASC]
    ): EmojisEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Fileinfo` mutation."
type DeleteFileinfoPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedFileinfoNodeId: ID
    "The `Fileinfo` that was deleted by this mutation."
    fileinfo: Fileinfo
    "An edge for our `Fileinfo`. May be used by Relay 1."
    fileinfoEdge(
        #The method to use when ordering `Fileinfo`.
        orderBy: [FileinfosOrderBy!] = [PRIMARY_KEY_ASC]
    ): FileinfosEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Groupchannel` mutation."
type DeleteGroupchannelPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedGroupchannelNodeId: ID
    "The `Groupchannel` that was deleted by this mutation."
    groupchannel: Groupchannel
    "An edge for our `Groupchannel`. May be used by Relay 1."
    groupchannelEdge(
        #The method to use when ordering `Groupchannel`.
        orderBy: [GroupchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupchannelsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Groupmember` mutation."
type DeleteGroupmemberPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedGroupmemberNodeId: ID
    "The `Groupmember` that was deleted by this mutation."
    groupmember: Groupmember
    "An edge for our `Groupmember`. May be used by Relay 1."
    groupmemberEdge(
        #The method to use when ordering `Groupmember`.
        orderBy: [GroupmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupmembersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Groupteam` mutation."
type DeleteGroupteamPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedGroupteamNodeId: ID
    "The `Groupteam` that was deleted by this mutation."
    groupteam: Groupteam
    "An edge for our `Groupteam`. May be used by Relay 1."
    groupteamEdge(
        #The method to use when ordering `Groupteam`.
        orderBy: [GroupteamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupteamsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Incomingwebhook` mutation."
type DeleteIncomingwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedIncomingwebhookNodeId: ID
    "The `Incomingwebhook` that was deleted by this mutation."
    incomingwebhook: Incomingwebhook
    "An edge for our `Incomingwebhook`. May be used by Relay 1."
    incomingwebhookEdge(
        #The method to use when ordering `Incomingwebhook`.
        orderBy: [IncomingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): IncomingwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Job` mutation."
type DeleteJobPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedJobNodeId: ID
    "The `Job` that was deleted by this mutation."
    job: Job
    "An edge for our `Job`. May be used by Relay 1."
    jobEdge(
        #The method to use when ordering `Job`.
        orderBy: [JobsOrderBy!] = [PRIMARY_KEY_ASC]
    ): JobsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `License` mutation."
type DeleteLicensePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedLicenseNodeId: ID
    "The `License` that was deleted by this mutation."
    license: License
    "An edge for our `License`. May be used by Relay 1."
    licenseEdge(
        #The method to use when ordering `License`.
        orderBy: [LicensesOrderBy!] = [PRIMARY_KEY_ASC]
    ): LicensesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Linkmetadatum` mutation."
type DeleteLinkmetadatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedLinkmetadatumNodeId: ID
    "The `Linkmetadatum` that was deleted by this mutation."
    linkmetadatum: Linkmetadatum
    "An edge for our `Linkmetadatum`. May be used by Relay 1."
    linkmetadatumEdge(
        #The method to use when ordering `Linkmetadatum`.
        orderBy: [LinkmetadataOrderBy!] = [PRIMARY_KEY_ASC]
    ): LinkmetadataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Oauthaccessdatum` mutation."
type DeleteOauthaccessdatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedOauthaccessdatumNodeId: ID
    "The `Oauthaccessdatum` that was deleted by this mutation."
    oauthaccessdatum: Oauthaccessdatum
    "An edge for our `Oauthaccessdatum`. May be used by Relay 1."
    oauthaccessdatumEdge(
        #The method to use when ordering `Oauthaccessdatum`.
        orderBy: [OauthaccessdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthaccessdataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Oauthapp` mutation."
type DeleteOauthappPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedOauthappNodeId: ID
    "The `Oauthapp` that was deleted by this mutation."
    oauthapp: Oauthapp
    "An edge for our `Oauthapp`. May be used by Relay 1."
    oauthappEdge(
        #The method to use when ordering `Oauthapp`.
        orderBy: [OauthappsOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthappsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Oauthauthdatum` mutation."
type DeleteOauthauthdatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedOauthauthdatumNodeId: ID
    "The `Oauthauthdatum` that was deleted by this mutation."
    oauthauthdatum: Oauthauthdatum
    "An edge for our `Oauthauthdatum`. May be used by Relay 1."
    oauthauthdatumEdge(
        #The method to use when ordering `Oauthauthdatum`.
        orderBy: [OauthauthdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthauthdataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Outgoingwebhook` mutation."
type DeleteOutgoingwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedOutgoingwebhookNodeId: ID
    "The `Outgoingwebhook` that was deleted by this mutation."
    outgoingwebhook: Outgoingwebhook
    "An edge for our `Outgoingwebhook`. May be used by Relay 1."
    outgoingwebhookEdge(
        #The method to use when ordering `Outgoingwebhook`.
        orderBy: [OutgoingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): OutgoingwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Pluginkeyvaluestore` mutation."
type DeletePluginkeyvaluestorePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedPluginkeyvaluestoreNodeId: ID
    "The `Pluginkeyvaluestore` that was deleted by this mutation."
    pluginkeyvaluestore: Pluginkeyvaluestore
    "An edge for our `Pluginkeyvaluestore`. May be used by Relay 1."
    pluginkeyvaluestoreEdge(
        #The method to use when ordering `Pluginkeyvaluestore`.
        orderBy: [PluginkeyvaluestoresOrderBy!] = [PRIMARY_KEY_ASC]
    ): PluginkeyvaluestoresEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Post` mutation."
type DeletePostPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedPostNodeId: ID
    "The `Post` that was deleted by this mutation."
    post: Post
    "An edge for our `Post`. May be used by Relay 1."
    postEdge(
        #The method to use when ordering `Post`.
        orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PostsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Post`."
    user: User
}

"The output of our delete `Preference` mutation."
type DeletePreferencePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedPreferenceNodeId: ID
    "The `Preference` that was deleted by this mutation."
    preference: Preference
    "An edge for our `Preference`. May be used by Relay 1."
    preferenceEdge(
        #The method to use when ordering `Preference`.
        orderBy: [PreferencesOrderBy!] = [PRIMARY_KEY_ASC]
    ): PreferencesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Publicchannel` mutation."
type DeletePublicchannelPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedPublicchannelNodeId: ID
    "The `Publicchannel` that was deleted by this mutation."
    publicchannel: Publicchannel
    "An edge for our `Publicchannel`. May be used by Relay 1."
    publicchannelEdge(
        #The method to use when ordering `Publicchannel`.
        orderBy: [PublicchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PublicchannelsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `Reaction` mutation."
type DeleteReactionPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedReactionNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Reaction` that was deleted by this mutation."
    reaction: Reaction
    "An edge for our `Reaction`. May be used by Relay 1."
    reactionEdge(
        #The method to use when ordering `Reaction`.
        orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ReactionsEdge
}

"The output of our delete `Role` mutation."
type DeleteRolePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedRoleNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Role` that was deleted by this mutation."
    role: Role
    "An edge for our `Role`. May be used by Relay 1."
    roleEdge(
        #The method to use when ordering `Role`.
        orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RolesEdge
}

"The output of our delete `Scheme` mutation."
type DeleteSchemePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedSchemeNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Scheme` that was deleted by this mutation."
    scheme: Scheme
    "An edge for our `Scheme`. May be used by Relay 1."
    schemeEdge(
        #The method to use when ordering `Scheme`.
        orderBy: [SchemesOrderBy!] = [PRIMARY_KEY_ASC]
    ): SchemesEdge
}

"The output of our delete `Session` mutation."
type DeleteSessionPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedSessionNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Session` that was deleted by this mutation."
    session: Session
    "An edge for our `Session`. May be used by Relay 1."
    sessionEdge(
        #The method to use when ordering `Session`.
        orderBy: [SessionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SessionsEdge
}

"The output of our delete `Status` mutation."
type DeleteStatusPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedStatusNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Status` that was deleted by this mutation."
    status: Status
    "An edge for our `Status`. May be used by Relay 1."
    statusEdge(
        #The method to use when ordering `Status`.
        orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StatusesEdge
}

"The output of our delete `System` mutation."
type DeleteSystemPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedSystemNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `System` that was deleted by this mutation."
    system: System
    "An edge for our `System`. May be used by Relay 1."
    systemEdge(
        #The method to use when ordering `System`.
        orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SystemsEdge
}

"The output of our delete `Team` mutation."
type DeleteTeamPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedTeamNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Team` that was deleted by this mutation."
    team: Team
    "An edge for our `Team`. May be used by Relay 1."
    teamEdge(
        #The method to use when ordering `Team`.
        orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeamsEdge
}

"The output of our delete `Teammember` mutation."
type DeleteTeammemberPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedTeammemberNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Teammember` that was deleted by this mutation."
    teammember: Teammember
    "An edge for our `Teammember`. May be used by Relay 1."
    teammemberEdge(
        #The method to use when ordering `Teammember`.
        orderBy: [TeammembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeammembersEdge
}

"The output of our delete `Termsofservice` mutation."
type DeleteTermsofservicePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedTermsofserviceNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Termsofservice` that was deleted by this mutation."
    termsofservice: Termsofservice
    "An edge for our `Termsofservice`. May be used by Relay 1."
    termsofserviceEdge(
        #The method to use when ordering `Termsofservice`.
        orderBy: [TermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): TermsofservicesEdge
}

"The output of our delete `Token` mutation."
type DeleteTokenPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedTokenNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Token` that was deleted by this mutation."
    token: Token
    "An edge for our `Token`. May be used by Relay 1."
    tokenEdge(
        #The method to use when ordering `Token`.
        orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): TokensEdge
}

"The output of our delete `User` mutation."
type DeleteUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedUserNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was deleted by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

"The output of our delete `Useraccesstoken` mutation."
type DeleteUseraccesstokenPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedUseraccesstokenNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Useraccesstoken` that was deleted by this mutation."
    useraccesstoken: Useraccesstoken
    "An edge for our `Useraccesstoken`. May be used by Relay 1."
    useraccesstokenEdge(
        #The method to use when ordering `Useraccesstoken`.
        orderBy: [UseraccesstokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): UseraccesstokensEdge
}

"The output of our delete `Usergroup` mutation."
type DeleteUsergroupPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedUsergroupNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Usergroup` that was deleted by this mutation."
    usergroup: Usergroup
    "An edge for our `Usergroup`. May be used by Relay 1."
    usergroupEdge(
        #The method to use when ordering `Usergroup`.
        orderBy: [UsergroupsOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsergroupsEdge
}

"The output of our delete `Usertermsofservice` mutation."
type DeleteUsertermsofservicePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedUsertermsofserviceNodeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Usertermsofservice` that was deleted by this mutation."
    usertermsofservice: Usertermsofservice
    "An edge for our `Usertermsofservice`. May be used by Relay 1."
    usertermsofserviceEdge(
        #The method to use when ordering `Usertermsofservice`.
        orderBy: [UsertermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsertermsofservicesEdge
}

type Emoji implements Node {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    id: String!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    updateat: BigInt
}

"A connection to a list of `Emoji` values."
type EmojisConnection {
    "A list of edges which contains the `Emoji` and cursor to aid in pagination."
    edges: [EmojisEdge!]!
    "A list of `Emoji` objects."
    nodes: [Emoji]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Emoji` you could get from the connection."
    totalCount: Int!
}

"A `Emoji` edge in the connection."
type EmojisEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Emoji` at the end of the edge."
    node: Emoji
}

type Fileinfo implements Node {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    extension: String
    haspreviewimage: Boolean
    height: Int
    id: String!
    mimetype: String
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    path: String
    postid: String
    previewpath: String
    size: BigInt
    thumbnailpath: String
    updateat: BigInt
    width: Int
}

"A connection to a list of `Fileinfo` values."
type FileinfosConnection {
    "A list of edges which contains the `Fileinfo` and cursor to aid in pagination."
    edges: [FileinfosEdge!]!
    "A list of `Fileinfo` objects."
    nodes: [Fileinfo]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Fileinfo` you could get from the connection."
    totalCount: Int!
}

"A `Fileinfo` edge in the connection."
type FileinfosEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Fileinfo` at the end of the edge."
    node: Fileinfo
}

type Groupchannel implements Node {
    autoadd: Boolean
    channelid: String!
    createat: BigInt
    deleteat: BigInt
    groupid: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    schemeadmin: Boolean
    updateat: BigInt
}

"A connection to a list of `Groupchannel` values."
type GroupchannelsConnection {
    "A list of edges which contains the `Groupchannel` and cursor to aid in pagination."
    edges: [GroupchannelsEdge!]!
    "A list of `Groupchannel` objects."
    nodes: [Groupchannel]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Groupchannel` you could get from the connection."
    totalCount: Int!
}

"A `Groupchannel` edge in the connection."
type GroupchannelsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Groupchannel` at the end of the edge."
    node: Groupchannel
}

type Groupmember implements Node {
    createat: BigInt
    deleteat: BigInt
    groupid: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    userid: String!
}

"A connection to a list of `Groupmember` values."
type GroupmembersConnection {
    "A list of edges which contains the `Groupmember` and cursor to aid in pagination."
    edges: [GroupmembersEdge!]!
    "A list of `Groupmember` objects."
    nodes: [Groupmember]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Groupmember` you could get from the connection."
    totalCount: Int!
}

"A `Groupmember` edge in the connection."
type GroupmembersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Groupmember` at the end of the edge."
    node: Groupmember
}

type Groupteam implements Node {
    autoadd: Boolean
    createat: BigInt
    deleteat: BigInt
    groupid: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    schemeadmin: Boolean
    teamid: String!
    updateat: BigInt
}

"A connection to a list of `Groupteam` values."
type GroupteamsConnection {
    "A list of edges which contains the `Groupteam` and cursor to aid in pagination."
    edges: [GroupteamsEdge!]!
    "A list of `Groupteam` objects."
    nodes: [Groupteam]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Groupteam` you could get from the connection."
    totalCount: Int!
}

"A `Groupteam` edge in the connection."
type GroupteamsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Groupteam` at the end of the edge."
    node: Groupteam
}

type Incomingwebhook implements Node {
    channelid: String
    channellocked: Boolean
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    teamid: String
    updateat: BigInt
    userid: String
    username: String
}

"A connection to a list of `Incomingwebhook` values."
type IncomingwebhooksConnection {
    "A list of edges which contains the `Incomingwebhook` and cursor to aid in pagination."
    edges: [IncomingwebhooksEdge!]!
    "A list of `Incomingwebhook` objects."
    nodes: [Incomingwebhook]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Incomingwebhook` you could get from the connection."
    totalCount: Int!
}

"A `Incomingwebhook` edge in the connection."
type IncomingwebhooksEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Incomingwebhook` at the end of the edge."
    node: Incomingwebhook
}

type Job implements Node {
    createat: BigInt
    data: String
    id: String!
    lastactivityat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    priority: BigInt
    progress: BigInt
    startat: BigInt
    status: String
    type: String
}

"A connection to a list of `Job` values."
type JobsConnection {
    "A list of edges which contains the `Job` and cursor to aid in pagination."
    edges: [JobsEdge!]!
    "A list of `Job` objects."
    nodes: [Job]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Job` you could get from the connection."
    totalCount: Int!
}

"A `Job` edge in the connection."
type JobsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Job` at the end of the edge."
    node: Job
}

type License implements Node {
    bytes: String
    createat: BigInt
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
}

"A connection to a list of `License` values."
type LicensesConnection {
    "A list of edges which contains the `License` and cursor to aid in pagination."
    edges: [LicensesEdge!]!
    "A list of `License` objects."
    nodes: [License]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `License` you could get from the connection."
    totalCount: Int!
}

"A `License` edge in the connection."
type LicensesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `License` at the end of the edge."
    node: License
}

"A connection to a list of `Linkmetadatum` values."
type LinkmetadataConnection {
    "A list of edges which contains the `Linkmetadatum` and cursor to aid in pagination."
    edges: [LinkmetadataEdge!]!
    "A list of `Linkmetadatum` objects."
    nodes: [Linkmetadatum]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Linkmetadatum` you could get from the connection."
    totalCount: Int!
}

"A `Linkmetadatum` edge in the connection."
type LinkmetadataEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Linkmetadatum` at the end of the edge."
    node: Linkmetadatum
}

type Linkmetadatum implements Node {
    data: String
    hash: BigInt!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    timestamp: BigInt
    type: String
    url: String
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
    "Creates a single `Audit`."
    createAudit(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateAuditInput!
    ): CreateAuditPayload
    "Creates a single `Bot`."
    createBot(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateBotInput!
    ): CreateBotPayload
    "Creates a single `Channel`."
    createChannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateChannelInput!
    ): CreateChannelPayload
    "Creates a single `Channelmember`."
    createChannelmember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateChannelmemberInput!
    ): CreateChannelmemberPayload
    "Creates a single `Channelmemberhistory`."
    createChannelmemberhistory(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateChannelmemberhistoryInput!
    ): CreateChannelmemberhistoryPayload
    "Creates a single `Clusterdiscovery`."
    createClusterdiscovery(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateClusterdiscoveryInput!
    ): CreateClusterdiscoveryPayload
    "Creates a single `Command`."
    createCommand(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateCommandInput!
    ): CreateCommandPayload
    "Creates a single `Commandwebhook`."
    createCommandwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateCommandwebhookInput!
    ): CreateCommandwebhookPayload
    "Creates a single `Compliance`."
    createCompliance(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateComplianceInput!
    ): CreateCompliancePayload
    "Creates a single `Emoji`."
    createEmoji(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateEmojiInput!
    ): CreateEmojiPayload
    "Creates a single `Fileinfo`."
    createFileinfo(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateFileinfoInput!
    ): CreateFileinfoPayload
    "Creates a single `Groupchannel`."
    createGroupchannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateGroupchannelInput!
    ): CreateGroupchannelPayload
    "Creates a single `Groupmember`."
    createGroupmember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateGroupmemberInput!
    ): CreateGroupmemberPayload
    "Creates a single `Groupteam`."
    createGroupteam(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateGroupteamInput!
    ): CreateGroupteamPayload
    "Creates a single `Incomingwebhook`."
    createIncomingwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateIncomingwebhookInput!
    ): CreateIncomingwebhookPayload
    "Creates a single `Job`."
    createJob(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateJobInput!
    ): CreateJobPayload
    "Creates a single `License`."
    createLicense(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateLicenseInput!
    ): CreateLicensePayload
    "Creates a single `Linkmetadatum`."
    createLinkmetadatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateLinkmetadatumInput!
    ): CreateLinkmetadatumPayload
    "Creates a single `Oauthaccessdatum`."
    createOauthaccessdatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateOauthaccessdatumInput!
    ): CreateOauthaccessdatumPayload
    "Creates a single `Oauthapp`."
    createOauthapp(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateOauthappInput!
    ): CreateOauthappPayload
    "Creates a single `Oauthauthdatum`."
    createOauthauthdatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateOauthauthdatumInput!
    ): CreateOauthauthdatumPayload
    "Creates a single `Outgoingwebhook`."
    createOutgoingwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateOutgoingwebhookInput!
    ): CreateOutgoingwebhookPayload
    "Creates a single `Pluginkeyvaluestore`."
    createPluginkeyvaluestore(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreatePluginkeyvaluestoreInput!
    ): CreatePluginkeyvaluestorePayload
    "Creates a single `Post`."
    createPost(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreatePostInput!
    ): CreatePostPayload
    "Creates a single `Preference`."
    createPreference(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreatePreferenceInput!
    ): CreatePreferencePayload
    "Creates a single `Publicchannel`."
    createPublicchannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreatePublicchannelInput!
    ): CreatePublicchannelPayload
    "Creates a single `Reaction`."
    createReaction(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateReactionInput!
    ): CreateReactionPayload
    "Creates a single `Role`."
    createRole(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateRoleInput!
    ): CreateRolePayload
    "Creates a single `Scheme`."
    createScheme(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateSchemeInput!
    ): CreateSchemePayload
    "Creates a single `Session`."
    createSession(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateSessionInput!
    ): CreateSessionPayload
    "Creates a single `Status`."
    createStatus(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateStatusInput!
    ): CreateStatusPayload
    "Creates a single `System`."
    createSystem(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateSystemInput!
    ): CreateSystemPayload
    "Creates a single `Team`."
    createTeam(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateTeamInput!
    ): CreateTeamPayload
    "Creates a single `Teammember`."
    createTeammember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateTeammemberInput!
    ): CreateTeammemberPayload
    "Creates a single `Termsofservice`."
    createTermsofservice(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateTermsofserviceInput!
    ): CreateTermsofservicePayload
    "Creates a single `Token`."
    createToken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateTokenInput!
    ): CreateTokenPayload
    "Creates a single `User`."
    createUser(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateUserInput!
    ): CreateUserPayload
    "Creates a single `Useraccesstoken`."
    createUseraccesstoken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateUseraccesstokenInput!
    ): CreateUseraccesstokenPayload
    "Creates a single `Usergroup`."
    createUsergroup(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateUsergroupInput!
    ): CreateUsergroupPayload
    "Creates a single `Usertermsofservice`."
    createUsertermsofservice(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: CreateUsertermsofserviceInput!
    ): CreateUsertermsofservicePayload
    "Deletes a single `Audit` using a unique key."
    deleteAudit(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteAuditInput!
    ): DeleteAuditPayload
    "Deletes a single `Audit` using its globally unique id."
    deleteAuditByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteAuditByNodeIdInput!
    ): DeleteAuditPayload
    "Deletes a single `Bot` using a unique key."
    deleteBot(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteBotInput!
    ): DeleteBotPayload
    "Deletes a single `Bot` using its globally unique id."
    deleteBotByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteBotByNodeIdInput!
    ): DeleteBotPayload
    "Deletes a single `Channel` using a unique key."
    deleteChannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelInput!
    ): DeleteChannelPayload
    "Deletes a single `Channel` using a unique key."
    deleteChannelByNameAndTeamid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelByNameAndTeamidInput!
    ): DeleteChannelPayload
    "Deletes a single `Channel` using its globally unique id."
    deleteChannelByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelByNodeIdInput!
    ): DeleteChannelPayload
    "Deletes a single `Channelmember` using a unique key."
    deleteChannelmember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelmemberInput!
    ): DeleteChannelmemberPayload
    "Deletes a single `Channelmember` using its globally unique id."
    deleteChannelmemberByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelmemberByNodeIdInput!
    ): DeleteChannelmemberPayload
    "Deletes a single `Channelmemberhistory` using a unique key."
    deleteChannelmemberhistory(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelmemberhistoryInput!
    ): DeleteChannelmemberhistoryPayload
    "Deletes a single `Channelmemberhistory` using its globally unique id."
    deleteChannelmemberhistoryByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteChannelmemberhistoryByNodeIdInput!
    ): DeleteChannelmemberhistoryPayload
    "Deletes a single `Clusterdiscovery` using a unique key."
    deleteClusterdiscovery(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteClusterdiscoveryInput!
    ): DeleteClusterdiscoveryPayload
    "Deletes a single `Clusterdiscovery` using its globally unique id."
    deleteClusterdiscoveryByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteClusterdiscoveryByNodeIdInput!
    ): DeleteClusterdiscoveryPayload
    "Deletes a single `Command` using a unique key."
    deleteCommand(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteCommandInput!
    ): DeleteCommandPayload
    "Deletes a single `Command` using its globally unique id."
    deleteCommandByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteCommandByNodeIdInput!
    ): DeleteCommandPayload
    "Deletes a single `Commandwebhook` using a unique key."
    deleteCommandwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteCommandwebhookInput!
    ): DeleteCommandwebhookPayload
    "Deletes a single `Commandwebhook` using its globally unique id."
    deleteCommandwebhookByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteCommandwebhookByNodeIdInput!
    ): DeleteCommandwebhookPayload
    "Deletes a single `Compliance` using a unique key."
    deleteCompliance(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteComplianceInput!
    ): DeleteCompliancePayload
    "Deletes a single `Compliance` using its globally unique id."
    deleteComplianceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteComplianceByNodeIdInput!
    ): DeleteCompliancePayload
    "Deletes a single `Emoji` using a unique key."
    deleteEmoji(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteEmojiInput!
    ): DeleteEmojiPayload
    "Deletes a single `Emoji` using a unique key."
    deleteEmojiByNameAndDeleteat(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteEmojiByNameAndDeleteatInput!
    ): DeleteEmojiPayload
    "Deletes a single `Emoji` using its globally unique id."
    deleteEmojiByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteEmojiByNodeIdInput!
    ): DeleteEmojiPayload
    "Deletes a single `Fileinfo` using a unique key."
    deleteFileinfo(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteFileinfoInput!
    ): DeleteFileinfoPayload
    "Deletes a single `Fileinfo` using its globally unique id."
    deleteFileinfoByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteFileinfoByNodeIdInput!
    ): DeleteFileinfoPayload
    "Deletes a single `Groupchannel` using a unique key."
    deleteGroupchannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteGroupchannelInput!
    ): DeleteGroupchannelPayload
    "Deletes a single `Groupchannel` using its globally unique id."
    deleteGroupchannelByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteGroupchannelByNodeIdInput!
    ): DeleteGroupchannelPayload
    "Deletes a single `Groupmember` using a unique key."
    deleteGroupmember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteGroupmemberInput!
    ): DeleteGroupmemberPayload
    "Deletes a single `Groupmember` using its globally unique id."
    deleteGroupmemberByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteGroupmemberByNodeIdInput!
    ): DeleteGroupmemberPayload
    "Deletes a single `Groupteam` using a unique key."
    deleteGroupteam(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteGroupteamInput!
    ): DeleteGroupteamPayload
    "Deletes a single `Groupteam` using its globally unique id."
    deleteGroupteamByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteGroupteamByNodeIdInput!
    ): DeleteGroupteamPayload
    "Deletes a single `Incomingwebhook` using a unique key."
    deleteIncomingwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteIncomingwebhookInput!
    ): DeleteIncomingwebhookPayload
    "Deletes a single `Incomingwebhook` using its globally unique id."
    deleteIncomingwebhookByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteIncomingwebhookByNodeIdInput!
    ): DeleteIncomingwebhookPayload
    "Deletes a single `Job` using a unique key."
    deleteJob(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteJobInput!
    ): DeleteJobPayload
    "Deletes a single `Job` using its globally unique id."
    deleteJobByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteJobByNodeIdInput!
    ): DeleteJobPayload
    "Deletes a single `License` using a unique key."
    deleteLicense(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteLicenseInput!
    ): DeleteLicensePayload
    "Deletes a single `License` using its globally unique id."
    deleteLicenseByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteLicenseByNodeIdInput!
    ): DeleteLicensePayload
    "Deletes a single `Linkmetadatum` using a unique key."
    deleteLinkmetadatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteLinkmetadatumInput!
    ): DeleteLinkmetadatumPayload
    "Deletes a single `Linkmetadatum` using its globally unique id."
    deleteLinkmetadatumByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteLinkmetadatumByNodeIdInput!
    ): DeleteLinkmetadatumPayload
    "Deletes a single `Oauthaccessdatum` using a unique key."
    deleteOauthaccessdatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthaccessdatumInput!
    ): DeleteOauthaccessdatumPayload
    "Deletes a single `Oauthaccessdatum` using a unique key."
    deleteOauthaccessdatumByClientidAndUserid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthaccessdatumByClientidAndUseridInput!
    ): DeleteOauthaccessdatumPayload
    "Deletes a single `Oauthaccessdatum` using its globally unique id."
    deleteOauthaccessdatumByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthaccessdatumByNodeIdInput!
    ): DeleteOauthaccessdatumPayload
    "Deletes a single `Oauthapp` using a unique key."
    deleteOauthapp(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthappInput!
    ): DeleteOauthappPayload
    "Deletes a single `Oauthapp` using its globally unique id."
    deleteOauthappByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthappByNodeIdInput!
    ): DeleteOauthappPayload
    "Deletes a single `Oauthauthdatum` using a unique key."
    deleteOauthauthdatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthauthdatumInput!
    ): DeleteOauthauthdatumPayload
    "Deletes a single `Oauthauthdatum` using its globally unique id."
    deleteOauthauthdatumByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOauthauthdatumByNodeIdInput!
    ): DeleteOauthauthdatumPayload
    "Deletes a single `Outgoingwebhook` using a unique key."
    deleteOutgoingwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOutgoingwebhookInput!
    ): DeleteOutgoingwebhookPayload
    "Deletes a single `Outgoingwebhook` using its globally unique id."
    deleteOutgoingwebhookByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteOutgoingwebhookByNodeIdInput!
    ): DeleteOutgoingwebhookPayload
    "Deletes a single `Pluginkeyvaluestore` using a unique key."
    deletePluginkeyvaluestore(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePluginkeyvaluestoreInput!
    ): DeletePluginkeyvaluestorePayload
    "Deletes a single `Pluginkeyvaluestore` using its globally unique id."
    deletePluginkeyvaluestoreByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePluginkeyvaluestoreByNodeIdInput!
    ): DeletePluginkeyvaluestorePayload
    "Deletes a single `Post` using a unique key."
    deletePost(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePostInput!
    ): DeletePostPayload
    "Deletes a single `Post` using its globally unique id."
    deletePostByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePostByNodeIdInput!
    ): DeletePostPayload
    "Deletes a single `Preference` using a unique key."
    deletePreference(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePreferenceInput!
    ): DeletePreferencePayload
    "Deletes a single `Preference` using its globally unique id."
    deletePreferenceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePreferenceByNodeIdInput!
    ): DeletePreferencePayload
    "Deletes a single `Publicchannel` using a unique key."
    deletePublicchannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePublicchannelInput!
    ): DeletePublicchannelPayload
    "Deletes a single `Publicchannel` using a unique key."
    deletePublicchannelByNameAndTeamid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePublicchannelByNameAndTeamidInput!
    ): DeletePublicchannelPayload
    "Deletes a single `Publicchannel` using its globally unique id."
    deletePublicchannelByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeletePublicchannelByNodeIdInput!
    ): DeletePublicchannelPayload
    "Deletes a single `Reaction` using a unique key."
    deleteReaction(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteReactionInput!
    ): DeleteReactionPayload
    "Deletes a single `Reaction` using its globally unique id."
    deleteReactionByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteReactionByNodeIdInput!
    ): DeleteReactionPayload
    "Deletes a single `Role` using a unique key."
    deleteRole(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteRoleInput!
    ): DeleteRolePayload
    "Deletes a single `Role` using a unique key."
    deleteRoleByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteRoleByNameInput!
    ): DeleteRolePayload
    "Deletes a single `Role` using its globally unique id."
    deleteRoleByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteRoleByNodeIdInput!
    ): DeleteRolePayload
    "Deletes a single `Scheme` using a unique key."
    deleteScheme(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSchemeInput!
    ): DeleteSchemePayload
    "Deletes a single `Scheme` using a unique key."
    deleteSchemeByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSchemeByNameInput!
    ): DeleteSchemePayload
    "Deletes a single `Scheme` using its globally unique id."
    deleteSchemeByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSchemeByNodeIdInput!
    ): DeleteSchemePayload
    "Deletes a single `Session` using a unique key."
    deleteSession(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSessionInput!
    ): DeleteSessionPayload
    "Deletes a single `Session` using its globally unique id."
    deleteSessionByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSessionByNodeIdInput!
    ): DeleteSessionPayload
    "Deletes a single `Status` using a unique key."
    deleteStatus(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteStatusInput!
    ): DeleteStatusPayload
    "Deletes a single `Status` using its globally unique id."
    deleteStatusByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteStatusByNodeIdInput!
    ): DeleteStatusPayload
    "Deletes a single `System` using a unique key."
    deleteSystem(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSystemInput!
    ): DeleteSystemPayload
    "Deletes a single `System` using its globally unique id."
    deleteSystemByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteSystemByNodeIdInput!
    ): DeleteSystemPayload
    "Deletes a single `Team` using a unique key."
    deleteTeam(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTeamInput!
    ): DeleteTeamPayload
    "Deletes a single `Team` using a unique key."
    deleteTeamByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTeamByNameInput!
    ): DeleteTeamPayload
    "Deletes a single `Team` using its globally unique id."
    deleteTeamByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTeamByNodeIdInput!
    ): DeleteTeamPayload
    "Deletes a single `Teammember` using a unique key."
    deleteTeammember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTeammemberInput!
    ): DeleteTeammemberPayload
    "Deletes a single `Teammember` using its globally unique id."
    deleteTeammemberByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTeammemberByNodeIdInput!
    ): DeleteTeammemberPayload
    "Deletes a single `Termsofservice` using a unique key."
    deleteTermsofservice(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTermsofserviceInput!
    ): DeleteTermsofservicePayload
    "Deletes a single `Termsofservice` using its globally unique id."
    deleteTermsofserviceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTermsofserviceByNodeIdInput!
    ): DeleteTermsofservicePayload
    "Deletes a single `Token` using a unique key."
    deleteToken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTokenInput!
    ): DeleteTokenPayload
    "Deletes a single `Token` using its globally unique id."
    deleteTokenByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteTokenByNodeIdInput!
    ): DeleteTokenPayload
    "Deletes a single `User` using a unique key."
    deleteUser(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUserInput!
    ): DeleteUserPayload
    "Deletes a single `User` using a unique key."
    deleteUserByAuthdata(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUserByAuthdataInput!
    ): DeleteUserPayload
    "Deletes a single `User` using a unique key."
    deleteUserByEmail(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUserByEmailInput!
    ): DeleteUserPayload
    "Deletes a single `User` using its globally unique id."
    deleteUserByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUserByNodeIdInput!
    ): DeleteUserPayload
    "Deletes a single `User` using a unique key."
    deleteUserByUsername(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUserByUsernameInput!
    ): DeleteUserPayload
    "Deletes a single `Useraccesstoken` using a unique key."
    deleteUseraccesstoken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUseraccesstokenInput!
    ): DeleteUseraccesstokenPayload
    "Deletes a single `Useraccesstoken` using its globally unique id."
    deleteUseraccesstokenByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUseraccesstokenByNodeIdInput!
    ): DeleteUseraccesstokenPayload
    "Deletes a single `Useraccesstoken` using a unique key."
    deleteUseraccesstokenByToken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUseraccesstokenByTokenInput!
    ): DeleteUseraccesstokenPayload
    "Deletes a single `Usergroup` using a unique key."
    deleteUsergroup(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUsergroupInput!
    ): DeleteUsergroupPayload
    "Deletes a single `Usergroup` using a unique key."
    deleteUsergroupByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUsergroupByNameInput!
    ): DeleteUsergroupPayload
    "Deletes a single `Usergroup` using its globally unique id."
    deleteUsergroupByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUsergroupByNodeIdInput!
    ): DeleteUsergroupPayload
    "Deletes a single `Usergroup` using a unique key."
    deleteUsergroupBySourceAndRemoteid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUsergroupBySourceAndRemoteidInput!
    ): DeleteUsergroupPayload
    "Deletes a single `Usertermsofservice` using a unique key."
    deleteUsertermsofservice(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUsertermsofserviceInput!
    ): DeleteUsertermsofservicePayload
    "Deletes a single `Usertermsofservice` using its globally unique id."
    deleteUsertermsofserviceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: DeleteUsertermsofserviceByNodeIdInput!
    ): DeleteUsertermsofservicePayload
    "Updates a single `Audit` using a unique key and a patch."
    updateAudit(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateAuditInput!
    ): UpdateAuditPayload
    "Updates a single `Audit` using its globally unique id and a patch."
    updateAuditByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateAuditByNodeIdInput!
    ): UpdateAuditPayload
    "Updates a single `Bot` using a unique key and a patch."
    updateBot(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateBotInput!
    ): UpdateBotPayload
    "Updates a single `Bot` using its globally unique id and a patch."
    updateBotByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateBotByNodeIdInput!
    ): UpdateBotPayload
    "Updates a single `Channel` using a unique key and a patch."
    updateChannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelInput!
    ): UpdateChannelPayload
    "Updates a single `Channel` using a unique key and a patch."
    updateChannelByNameAndTeamid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelByNameAndTeamidInput!
    ): UpdateChannelPayload
    "Updates a single `Channel` using its globally unique id and a patch."
    updateChannelByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelByNodeIdInput!
    ): UpdateChannelPayload
    "Updates a single `Channelmember` using a unique key and a patch."
    updateChannelmember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelmemberInput!
    ): UpdateChannelmemberPayload
    "Updates a single `Channelmember` using its globally unique id and a patch."
    updateChannelmemberByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelmemberByNodeIdInput!
    ): UpdateChannelmemberPayload
    "Updates a single `Channelmemberhistory` using a unique key and a patch."
    updateChannelmemberhistory(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelmemberhistoryInput!
    ): UpdateChannelmemberhistoryPayload
    "Updates a single `Channelmemberhistory` using its globally unique id and a patch."
    updateChannelmemberhistoryByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateChannelmemberhistoryByNodeIdInput!
    ): UpdateChannelmemberhistoryPayload
    "Updates a single `Clusterdiscovery` using a unique key and a patch."
    updateClusterdiscovery(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateClusterdiscoveryInput!
    ): UpdateClusterdiscoveryPayload
    "Updates a single `Clusterdiscovery` using its globally unique id and a patch."
    updateClusterdiscoveryByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateClusterdiscoveryByNodeIdInput!
    ): UpdateClusterdiscoveryPayload
    "Updates a single `Command` using a unique key and a patch."
    updateCommand(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateCommandInput!
    ): UpdateCommandPayload
    "Updates a single `Command` using its globally unique id and a patch."
    updateCommandByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateCommandByNodeIdInput!
    ): UpdateCommandPayload
    "Updates a single `Commandwebhook` using a unique key and a patch."
    updateCommandwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateCommandwebhookInput!
    ): UpdateCommandwebhookPayload
    "Updates a single `Commandwebhook` using its globally unique id and a patch."
    updateCommandwebhookByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateCommandwebhookByNodeIdInput!
    ): UpdateCommandwebhookPayload
    "Updates a single `Compliance` using a unique key and a patch."
    updateCompliance(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateComplianceInput!
    ): UpdateCompliancePayload
    "Updates a single `Compliance` using its globally unique id and a patch."
    updateComplianceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateComplianceByNodeIdInput!
    ): UpdateCompliancePayload
    "Updates a single `Emoji` using a unique key and a patch."
    updateEmoji(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateEmojiInput!
    ): UpdateEmojiPayload
    "Updates a single `Emoji` using a unique key and a patch."
    updateEmojiByNameAndDeleteat(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateEmojiByNameAndDeleteatInput!
    ): UpdateEmojiPayload
    "Updates a single `Emoji` using its globally unique id and a patch."
    updateEmojiByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateEmojiByNodeIdInput!
    ): UpdateEmojiPayload
    "Updates a single `Fileinfo` using a unique key and a patch."
    updateFileinfo(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateFileinfoInput!
    ): UpdateFileinfoPayload
    "Updates a single `Fileinfo` using its globally unique id and a patch."
    updateFileinfoByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateFileinfoByNodeIdInput!
    ): UpdateFileinfoPayload
    "Updates a single `Groupchannel` using a unique key and a patch."
    updateGroupchannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateGroupchannelInput!
    ): UpdateGroupchannelPayload
    "Updates a single `Groupchannel` using its globally unique id and a patch."
    updateGroupchannelByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateGroupchannelByNodeIdInput!
    ): UpdateGroupchannelPayload
    "Updates a single `Groupmember` using a unique key and a patch."
    updateGroupmember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateGroupmemberInput!
    ): UpdateGroupmemberPayload
    "Updates a single `Groupmember` using its globally unique id and a patch."
    updateGroupmemberByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateGroupmemberByNodeIdInput!
    ): UpdateGroupmemberPayload
    "Updates a single `Groupteam` using a unique key and a patch."
    updateGroupteam(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateGroupteamInput!
    ): UpdateGroupteamPayload
    "Updates a single `Groupteam` using its globally unique id and a patch."
    updateGroupteamByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateGroupteamByNodeIdInput!
    ): UpdateGroupteamPayload
    "Updates a single `Incomingwebhook` using a unique key and a patch."
    updateIncomingwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateIncomingwebhookInput!
    ): UpdateIncomingwebhookPayload
    "Updates a single `Incomingwebhook` using its globally unique id and a patch."
    updateIncomingwebhookByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateIncomingwebhookByNodeIdInput!
    ): UpdateIncomingwebhookPayload
    "Updates a single `Job` using a unique key and a patch."
    updateJob(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateJobInput!
    ): UpdateJobPayload
    "Updates a single `Job` using its globally unique id and a patch."
    updateJobByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateJobByNodeIdInput!
    ): UpdateJobPayload
    "Updates a single `License` using a unique key and a patch."
    updateLicense(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateLicenseInput!
    ): UpdateLicensePayload
    "Updates a single `License` using its globally unique id and a patch."
    updateLicenseByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateLicenseByNodeIdInput!
    ): UpdateLicensePayload
    "Updates a single `Linkmetadatum` using a unique key and a patch."
    updateLinkmetadatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateLinkmetadatumInput!
    ): UpdateLinkmetadatumPayload
    "Updates a single `Linkmetadatum` using its globally unique id and a patch."
    updateLinkmetadatumByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateLinkmetadatumByNodeIdInput!
    ): UpdateLinkmetadatumPayload
    "Updates a single `Oauthaccessdatum` using a unique key and a patch."
    updateOauthaccessdatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthaccessdatumInput!
    ): UpdateOauthaccessdatumPayload
    "Updates a single `Oauthaccessdatum` using a unique key and a patch."
    updateOauthaccessdatumByClientidAndUserid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthaccessdatumByClientidAndUseridInput!
    ): UpdateOauthaccessdatumPayload
    "Updates a single `Oauthaccessdatum` using its globally unique id and a patch."
    updateOauthaccessdatumByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthaccessdatumByNodeIdInput!
    ): UpdateOauthaccessdatumPayload
    "Updates a single `Oauthapp` using a unique key and a patch."
    updateOauthapp(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthappInput!
    ): UpdateOauthappPayload
    "Updates a single `Oauthapp` using its globally unique id and a patch."
    updateOauthappByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthappByNodeIdInput!
    ): UpdateOauthappPayload
    "Updates a single `Oauthauthdatum` using a unique key and a patch."
    updateOauthauthdatum(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthauthdatumInput!
    ): UpdateOauthauthdatumPayload
    "Updates a single `Oauthauthdatum` using its globally unique id and a patch."
    updateOauthauthdatumByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOauthauthdatumByNodeIdInput!
    ): UpdateOauthauthdatumPayload
    "Updates a single `Outgoingwebhook` using a unique key and a patch."
    updateOutgoingwebhook(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOutgoingwebhookInput!
    ): UpdateOutgoingwebhookPayload
    "Updates a single `Outgoingwebhook` using its globally unique id and a patch."
    updateOutgoingwebhookByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateOutgoingwebhookByNodeIdInput!
    ): UpdateOutgoingwebhookPayload
    "Updates a single `Pluginkeyvaluestore` using a unique key and a patch."
    updatePluginkeyvaluestore(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePluginkeyvaluestoreInput!
    ): UpdatePluginkeyvaluestorePayload
    "Updates a single `Pluginkeyvaluestore` using its globally unique id and a patch."
    updatePluginkeyvaluestoreByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePluginkeyvaluestoreByNodeIdInput!
    ): UpdatePluginkeyvaluestorePayload
    "Updates a single `Post` using a unique key and a patch."
    updatePost(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePostInput!
    ): UpdatePostPayload
    "Updates a single `Post` using its globally unique id and a patch."
    updatePostByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePostByNodeIdInput!
    ): UpdatePostPayload
    "Updates a single `Preference` using a unique key and a patch."
    updatePreference(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePreferenceInput!
    ): UpdatePreferencePayload
    "Updates a single `Preference` using its globally unique id and a patch."
    updatePreferenceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePreferenceByNodeIdInput!
    ): UpdatePreferencePayload
    "Updates a single `Publicchannel` using a unique key and a patch."
    updatePublicchannel(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePublicchannelInput!
    ): UpdatePublicchannelPayload
    "Updates a single `Publicchannel` using a unique key and a patch."
    updatePublicchannelByNameAndTeamid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePublicchannelByNameAndTeamidInput!
    ): UpdatePublicchannelPayload
    "Updates a single `Publicchannel` using its globally unique id and a patch."
    updatePublicchannelByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdatePublicchannelByNodeIdInput!
    ): UpdatePublicchannelPayload
    "Updates a single `Reaction` using a unique key and a patch."
    updateReaction(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateReactionInput!
    ): UpdateReactionPayload
    "Updates a single `Reaction` using its globally unique id and a patch."
    updateReactionByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateReactionByNodeIdInput!
    ): UpdateReactionPayload
    "Updates a single `Role` using a unique key and a patch."
    updateRole(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateRoleInput!
    ): UpdateRolePayload
    "Updates a single `Role` using a unique key and a patch."
    updateRoleByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateRoleByNameInput!
    ): UpdateRolePayload
    "Updates a single `Role` using its globally unique id and a patch."
    updateRoleByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateRoleByNodeIdInput!
    ): UpdateRolePayload
    "Updates a single `Scheme` using a unique key and a patch."
    updateScheme(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSchemeInput!
    ): UpdateSchemePayload
    "Updates a single `Scheme` using a unique key and a patch."
    updateSchemeByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSchemeByNameInput!
    ): UpdateSchemePayload
    "Updates a single `Scheme` using its globally unique id and a patch."
    updateSchemeByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSchemeByNodeIdInput!
    ): UpdateSchemePayload
    "Updates a single `Session` using a unique key and a patch."
    updateSession(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSessionInput!
    ): UpdateSessionPayload
    "Updates a single `Session` using its globally unique id and a patch."
    updateSessionByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSessionByNodeIdInput!
    ): UpdateSessionPayload
    "Updates a single `Status` using a unique key and a patch."
    updateStatus(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateStatusInput!
    ): UpdateStatusPayload
    "Updates a single `Status` using its globally unique id and a patch."
    updateStatusByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateStatusByNodeIdInput!
    ): UpdateStatusPayload
    "Updates a single `System` using a unique key and a patch."
    updateSystem(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSystemInput!
    ): UpdateSystemPayload
    "Updates a single `System` using its globally unique id and a patch."
    updateSystemByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateSystemByNodeIdInput!
    ): UpdateSystemPayload
    "Updates a single `Team` using a unique key and a patch."
    updateTeam(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTeamInput!
    ): UpdateTeamPayload
    "Updates a single `Team` using a unique key and a patch."
    updateTeamByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTeamByNameInput!
    ): UpdateTeamPayload
    "Updates a single `Team` using its globally unique id and a patch."
    updateTeamByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTeamByNodeIdInput!
    ): UpdateTeamPayload
    "Updates a single `Teammember` using a unique key and a patch."
    updateTeammember(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTeammemberInput!
    ): UpdateTeammemberPayload
    "Updates a single `Teammember` using its globally unique id and a patch."
    updateTeammemberByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTeammemberByNodeIdInput!
    ): UpdateTeammemberPayload
    "Updates a single `Termsofservice` using a unique key and a patch."
    updateTermsofservice(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTermsofserviceInput!
    ): UpdateTermsofservicePayload
    "Updates a single `Termsofservice` using its globally unique id and a patch."
    updateTermsofserviceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTermsofserviceByNodeIdInput!
    ): UpdateTermsofservicePayload
    "Updates a single `Token` using a unique key and a patch."
    updateToken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTokenInput!
    ): UpdateTokenPayload
    "Updates a single `Token` using its globally unique id and a patch."
    updateTokenByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateTokenByNodeIdInput!
    ): UpdateTokenPayload
    "Updates a single `User` using a unique key and a patch."
    updateUser(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUserInput!
    ): UpdateUserPayload
    "Updates a single `User` using a unique key and a patch."
    updateUserByAuthdata(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUserByAuthdataInput!
    ): UpdateUserPayload
    "Updates a single `User` using a unique key and a patch."
    updateUserByEmail(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUserByEmailInput!
    ): UpdateUserPayload
    "Updates a single `User` using its globally unique id and a patch."
    updateUserByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUserByNodeIdInput!
    ): UpdateUserPayload
    "Updates a single `User` using a unique key and a patch."
    updateUserByUsername(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUserByUsernameInput!
    ): UpdateUserPayload
    "Updates a single `Useraccesstoken` using a unique key and a patch."
    updateUseraccesstoken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUseraccesstokenInput!
    ): UpdateUseraccesstokenPayload
    "Updates a single `Useraccesstoken` using its globally unique id and a patch."
    updateUseraccesstokenByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUseraccesstokenByNodeIdInput!
    ): UpdateUseraccesstokenPayload
    "Updates a single `Useraccesstoken` using a unique key and a patch."
    updateUseraccesstokenByToken(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUseraccesstokenByTokenInput!
    ): UpdateUseraccesstokenPayload
    "Updates a single `Usergroup` using a unique key and a patch."
    updateUsergroup(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUsergroupInput!
    ): UpdateUsergroupPayload
    "Updates a single `Usergroup` using a unique key and a patch."
    updateUsergroupByName(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUsergroupByNameInput!
    ): UpdateUsergroupPayload
    "Updates a single `Usergroup` using its globally unique id and a patch."
    updateUsergroupByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUsergroupByNodeIdInput!
    ): UpdateUsergroupPayload
    "Updates a single `Usergroup` using a unique key and a patch."
    updateUsergroupBySourceAndRemoteid(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUsergroupBySourceAndRemoteidInput!
    ): UpdateUsergroupPayload
    "Updates a single `Usertermsofservice` using a unique key and a patch."
    updateUsertermsofservice(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUsertermsofserviceInput!
    ): UpdateUsertermsofservicePayload
    "Updates a single `Usertermsofservice` using its globally unique id and a patch."
    updateUsertermsofserviceByNodeId(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
        input: UpdateUsertermsofserviceByNodeIdInput!
    ): UpdateUsertermsofservicePayload
}

"A connection to a list of `Oauthaccessdatum` values."
type OauthaccessdataConnection {
    "A list of edges which contains the `Oauthaccessdatum` and cursor to aid in pagination."
    edges: [OauthaccessdataEdge!]!
    "A list of `Oauthaccessdatum` objects."
    nodes: [Oauthaccessdatum]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Oauthaccessdatum` you could get from the connection."
    totalCount: Int!
}

"A `Oauthaccessdatum` edge in the connection."
type OauthaccessdataEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Oauthaccessdatum` at the end of the edge."
    node: Oauthaccessdatum
}

type Oauthaccessdatum implements Node {
    clientid: String
    expiresat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    redirecturi: String
    refreshtoken: String
    scope: String
    token: String!
    userid: String
}

type Oauthapp implements Node {
    callbackurls: String
    clientsecret: String
    createat: BigInt
    creatorid: String
    description: String
    homepage: String
    iconurl: String
    id: String!
    istrusted: Boolean
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    updateat: BigInt
}

"A connection to a list of `Oauthapp` values."
type OauthappsConnection {
    "A list of edges which contains the `Oauthapp` and cursor to aid in pagination."
    edges: [OauthappsEdge!]!
    "A list of `Oauthapp` objects."
    nodes: [Oauthapp]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Oauthapp` you could get from the connection."
    totalCount: Int!
}

"A `Oauthapp` edge in the connection."
type OauthappsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Oauthapp` at the end of the edge."
    node: Oauthapp
}

"A connection to a list of `Oauthauthdatum` values."
type OauthauthdataConnection {
    "A list of edges which contains the `Oauthauthdatum` and cursor to aid in pagination."
    edges: [OauthauthdataEdge!]!
    "A list of `Oauthauthdatum` objects."
    nodes: [Oauthauthdatum]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Oauthauthdatum` you could get from the connection."
    totalCount: Int!
}

"A `Oauthauthdatum` edge in the connection."
type OauthauthdataEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Oauthauthdatum` at the end of the edge."
    node: Oauthauthdatum
}

type Oauthauthdatum implements Node {
    clientid: String
    code: String!
    createat: BigInt
    expiresin: Int
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    redirecturi: String
    scope: String
    state: String
    userid: String
}

type Outgoingwebhook implements Node {
    callbackurls: String
    channelid: String
    contenttype: String
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    teamid: String
    token: String
    triggerwhen: Int
    triggerwords: String
    updateat: BigInt
    username: String
}

"A connection to a list of `Outgoingwebhook` values."
type OutgoingwebhooksConnection {
    "A list of edges which contains the `Outgoingwebhook` and cursor to aid in pagination."
    edges: [OutgoingwebhooksEdge!]!
    "A list of `Outgoingwebhook` objects."
    nodes: [Outgoingwebhook]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Outgoingwebhook` you could get from the connection."
    totalCount: Int!
}

"A `Outgoingwebhook` edge in the connection."
type OutgoingwebhooksEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Outgoingwebhook` at the end of the edge."
    node: Outgoingwebhook
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: Cursor
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: Cursor
}

type Pluginkeyvaluestore implements Node {
    expireat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    pkey: String!
    pluginid: String!
    pvalue: String
}

"A connection to a list of `Pluginkeyvaluestore` values."
type PluginkeyvaluestoresConnection {
    "A list of edges which contains the `Pluginkeyvaluestore` and cursor to aid in pagination."
    edges: [PluginkeyvaluestoresEdge!]!
    "A list of `Pluginkeyvaluestore` objects."
    nodes: [Pluginkeyvaluestore]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Pluginkeyvaluestore` you could get from the connection."
    totalCount: Int!
}

"A `Pluginkeyvaluestore` edge in the connection."
type PluginkeyvaluestoresEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Pluginkeyvaluestore` at the end of the edge."
    node: Pluginkeyvaluestore
}

type Post implements Node {
    channelid: String
    createat: BigInt
    deleteat: BigInt
    editat: BigInt
    fileids: String
    filenames: String
    hashtags: String
    hasreactions: Boolean
    id: String!
    ispinned: Boolean
    message: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    originalid: String
    parentid: String
    props: String
    rootid: String
    type: String
    updateat: BigInt
    "Reads a single `User` that is related to this `Post`."
    user: User
    userId: String
}

"A connection to a list of `Post` values."
type PostsConnection {
    "A list of edges which contains the `Post` and cursor to aid in pagination."
    edges: [PostsEdge!]!
    "A list of `Post` objects."
    nodes: [Post]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Post` you could get from the connection."
    totalCount: Int!
}

"A `Post` edge in the connection."
type PostsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Post` at the end of the edge."
    node: Post
}

type Preference implements Node {
    category: String!
    name: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    userid: String!
    value: String
}

"A connection to a list of `Preference` values."
type PreferencesConnection {
    "A list of edges which contains the `Preference` and cursor to aid in pagination."
    edges: [PreferencesEdge!]!
    "A list of `Preference` objects."
    nodes: [Preference]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Preference` you could get from the connection."
    totalCount: Int!
}

"A `Preference` edge in the connection."
type PreferencesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Preference` at the end of the edge."
    node: Preference
}

type Publicchannel implements Node {
    deleteat: BigInt
    displayname: String
    header: String
    id: String!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    purpose: String
    teamid: String
}

"A connection to a list of `Publicchannel` values."
type PublicchannelsConnection {
    "A list of edges which contains the `Publicchannel` and cursor to aid in pagination."
    edges: [PublicchannelsEdge!]!
    "A list of `Publicchannel` objects."
    nodes: [Publicchannel]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Publicchannel` you could get from the connection."
    totalCount: Int!
}

"A `Publicchannel` edge in the connection."
type PublicchannelsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Publicchannel` at the end of the edge."
    node: Publicchannel
}

"The root query type which gives access points into the data universe."
type Query implements Node {
    audit(id: String!): Audit
    "Reads a single `Audit` using its globally unique `ID`."
    auditByNodeId(
        #The globally unique `ID` to be used in selecting a single `Audit`.
        nodeId: ID!
    ): Audit
    "Reads and enables pagination through a set of `Audit`."
    audits(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: AuditCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Audit`.
        orderBy: [AuditsOrderBy!] = [PRIMARY_KEY_ASC]
    ): AuditsConnection
    bot(userid: String!): Bot
    "Reads a single `Bot` using its globally unique `ID`."
    botByNodeId(
        #The globally unique `ID` to be used in selecting a single `Bot`.
        nodeId: ID!
    ): Bot
    "Reads and enables pagination through a set of `Bot`."
    bots(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: BotCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Bot`.
        orderBy: [BotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): BotsConnection
    channel(id: String!): Channel
    channelByNameAndTeamid(name: String!, teamid: String!): Channel
    "Reads a single `Channel` using its globally unique `ID`."
    channelByNodeId(
        #The globally unique `ID` to be used in selecting a single `Channel`.
        nodeId: ID!
    ): Channel
    channelmember(channelid: String!, userid: String!): Channelmember
    "Reads a single `Channelmember` using its globally unique `ID`."
    channelmemberByNodeId(
        #The globally unique `ID` to be used in selecting a single `Channelmember`.
        nodeId: ID!
    ): Channelmember
    "Reads and enables pagination through a set of `Channelmemberhistory`."
    channelmemberhistories(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ChannelmemberhistoryCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Channelmemberhistory`.
        orderBy: [ChannelmemberhistoriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmemberhistoriesConnection
    channelmemberhistory(channelid: String!, jointime: BigInt!, userid: String!): Channelmemberhistory
    "Reads a single `Channelmemberhistory` using its globally unique `ID`."
    channelmemberhistoryByNodeId(
        #The globally unique `ID` to be used in selecting a single `Channelmemberhistory`.
        nodeId: ID!
    ): Channelmemberhistory
    "Reads and enables pagination through a set of `Channelmember`."
    channelmembers(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ChannelmemberCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Channelmember`.
        orderBy: [ChannelmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmembersConnection
    "Reads and enables pagination through a set of `Channel`."
    channels(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ChannelCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Channel`.
        orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelsConnection
    "Reads and enables pagination through a set of `Clusterdiscovery`."
    clusterdiscoveries(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ClusterdiscoveryCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Clusterdiscovery`.
        orderBy: [ClusterdiscoveriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClusterdiscoveriesConnection
    clusterdiscovery(id: String!): Clusterdiscovery
    "Reads a single `Clusterdiscovery` using its globally unique `ID`."
    clusterdiscoveryByNodeId(
        #The globally unique `ID` to be used in selecting a single `Clusterdiscovery`.
        nodeId: ID!
    ): Clusterdiscovery
    command(id: String!): Command
    "Reads a single `Command` using its globally unique `ID`."
    commandByNodeId(
        #The globally unique `ID` to be used in selecting a single `Command`.
        nodeId: ID!
    ): Command
    "Reads and enables pagination through a set of `Command`."
    commands(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: CommandCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Command`.
        orderBy: [CommandsOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandsConnection
    commandwebhook(id: String!): Commandwebhook
    "Reads a single `Commandwebhook` using its globally unique `ID`."
    commandwebhookByNodeId(
        #The globally unique `ID` to be used in selecting a single `Commandwebhook`.
        nodeId: ID!
    ): Commandwebhook
    "Reads and enables pagination through a set of `Commandwebhook`."
    commandwebhooks(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: CommandwebhookCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Commandwebhook`.
        orderBy: [CommandwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandwebhooksConnection
    compliance(id: String!): Compliance
    "Reads a single `Compliance` using its globally unique `ID`."
    complianceByNodeId(
        #The globally unique `ID` to be used in selecting a single `Compliance`.
        nodeId: ID!
    ): Compliance
    "Reads and enables pagination through a set of `Compliance`."
    compliances(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ComplianceCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Compliance`.
        orderBy: [CompliancesOrderBy!] = [PRIMARY_KEY_ASC]
    ): CompliancesConnection
    emoji(id: String!): Emoji
    emojiByNameAndDeleteat(deleteat: BigInt!, name: String!): Emoji
    "Reads a single `Emoji` using its globally unique `ID`."
    emojiByNodeId(
        #The globally unique `ID` to be used in selecting a single `Emoji`.
        nodeId: ID!
    ): Emoji
    "Reads and enables pagination through a set of `Emoji`."
    emojis(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: EmojiCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Emoji`.
        orderBy: [EmojisOrderBy!] = [PRIMARY_KEY_ASC]
    ): EmojisConnection
    fileinfo(id: String!): Fileinfo
    "Reads a single `Fileinfo` using its globally unique `ID`."
    fileinfoByNodeId(
        #The globally unique `ID` to be used in selecting a single `Fileinfo`.
        nodeId: ID!
    ): Fileinfo
    "Reads and enables pagination through a set of `Fileinfo`."
    fileinfos(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: FileinfoCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Fileinfo`.
        orderBy: [FileinfosOrderBy!] = [PRIMARY_KEY_ASC]
    ): FileinfosConnection
    groupchannel(channelid: String!, groupid: String!): Groupchannel
    "Reads a single `Groupchannel` using its globally unique `ID`."
    groupchannelByNodeId(
        #The globally unique `ID` to be used in selecting a single `Groupchannel`.
        nodeId: ID!
    ): Groupchannel
    "Reads and enables pagination through a set of `Groupchannel`."
    groupchannels(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: GroupchannelCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Groupchannel`.
        orderBy: [GroupchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupchannelsConnection
    groupmember(groupid: String!, userid: String!): Groupmember
    "Reads a single `Groupmember` using its globally unique `ID`."
    groupmemberByNodeId(
        #The globally unique `ID` to be used in selecting a single `Groupmember`.
        nodeId: ID!
    ): Groupmember
    "Reads and enables pagination through a set of `Groupmember`."
    groupmembers(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: GroupmemberCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Groupmember`.
        orderBy: [GroupmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupmembersConnection
    groupteam(groupid: String!, teamid: String!): Groupteam
    "Reads a single `Groupteam` using its globally unique `ID`."
    groupteamByNodeId(
        #The globally unique `ID` to be used in selecting a single `Groupteam`.
        nodeId: ID!
    ): Groupteam
    "Reads and enables pagination through a set of `Groupteam`."
    groupteams(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: GroupteamCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Groupteam`.
        orderBy: [GroupteamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupteamsConnection
    incomingwebhook(id: String!): Incomingwebhook
    "Reads a single `Incomingwebhook` using its globally unique `ID`."
    incomingwebhookByNodeId(
        #The globally unique `ID` to be used in selecting a single `Incomingwebhook`.
        nodeId: ID!
    ): Incomingwebhook
    "Reads and enables pagination through a set of `Incomingwebhook`."
    incomingwebhooks(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: IncomingwebhookCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Incomingwebhook`.
        orderBy: [IncomingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): IncomingwebhooksConnection
    job(id: String!): Job
    "Reads a single `Job` using its globally unique `ID`."
    jobByNodeId(
        #The globally unique `ID` to be used in selecting a single `Job`.
        nodeId: ID!
    ): Job
    "Reads and enables pagination through a set of `Job`."
    jobs(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: JobCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Job`.
        orderBy: [JobsOrderBy!] = [PRIMARY_KEY_ASC]
    ): JobsConnection
    license(id: String!): License
    "Reads a single `License` using its globally unique `ID`."
    licenseByNodeId(
        #The globally unique `ID` to be used in selecting a single `License`.
        nodeId: ID!
    ): License
    "Reads and enables pagination through a set of `License`."
    licenses(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: LicenseCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `License`.
        orderBy: [LicensesOrderBy!] = [PRIMARY_KEY_ASC]
    ): LicensesConnection
    "Reads and enables pagination through a set of `Linkmetadatum`."
    linkmetadata(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: LinkmetadatumCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Linkmetadatum`.
        orderBy: [LinkmetadataOrderBy!] = [PRIMARY_KEY_ASC]
    ): LinkmetadataConnection
    linkmetadatum(hash: BigInt!): Linkmetadatum
    "Reads a single `Linkmetadatum` using its globally unique `ID`."
    linkmetadatumByNodeId(
        #The globally unique `ID` to be used in selecting a single `Linkmetadatum`.
        nodeId: ID!
    ): Linkmetadatum
    "Fetches an object given its globally unique `ID`."
    node(
        #The globally unique `ID`.
        nodeId: ID!
    ): Node
    "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
    nodeId: ID!
    "Reads and enables pagination through a set of `Oauthaccessdatum`."
    oauthaccessdata(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: OauthaccessdatumCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Oauthaccessdatum`.
        orderBy: [OauthaccessdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthaccessdataConnection
    oauthaccessdatum(token: String!): Oauthaccessdatum
    oauthaccessdatumByClientidAndUserid(clientid: String!, userid: String!): Oauthaccessdatum
    "Reads a single `Oauthaccessdatum` using its globally unique `ID`."
    oauthaccessdatumByNodeId(
        #The globally unique `ID` to be used in selecting a single `Oauthaccessdatum`.
        nodeId: ID!
    ): Oauthaccessdatum
    oauthapp(id: String!): Oauthapp
    "Reads a single `Oauthapp` using its globally unique `ID`."
    oauthappByNodeId(
        #The globally unique `ID` to be used in selecting a single `Oauthapp`.
        nodeId: ID!
    ): Oauthapp
    "Reads and enables pagination through a set of `Oauthapp`."
    oauthapps(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: OauthappCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Oauthapp`.
        orderBy: [OauthappsOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthappsConnection
    "Reads and enables pagination through a set of `Oauthauthdatum`."
    oauthauthdata(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: OauthauthdatumCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Oauthauthdatum`.
        orderBy: [OauthauthdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthauthdataConnection
    oauthauthdatum(code: String!): Oauthauthdatum
    "Reads a single `Oauthauthdatum` using its globally unique `ID`."
    oauthauthdatumByNodeId(
        #The globally unique `ID` to be used in selecting a single `Oauthauthdatum`.
        nodeId: ID!
    ): Oauthauthdatum
    outgoingwebhook(id: String!): Outgoingwebhook
    "Reads a single `Outgoingwebhook` using its globally unique `ID`."
    outgoingwebhookByNodeId(
        #The globally unique `ID` to be used in selecting a single `Outgoingwebhook`.
        nodeId: ID!
    ): Outgoingwebhook
    "Reads and enables pagination through a set of `Outgoingwebhook`."
    outgoingwebhooks(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: OutgoingwebhookCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Outgoingwebhook`.
        orderBy: [OutgoingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): OutgoingwebhooksConnection
    pluginkeyvaluestore(pkey: String!, pluginid: String!): Pluginkeyvaluestore
    "Reads a single `Pluginkeyvaluestore` using its globally unique `ID`."
    pluginkeyvaluestoreByNodeId(
        #The globally unique `ID` to be used in selecting a single `Pluginkeyvaluestore`.
        nodeId: ID!
    ): Pluginkeyvaluestore
    "Reads and enables pagination through a set of `Pluginkeyvaluestore`."
    pluginkeyvaluestores(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: PluginkeyvaluestoreCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Pluginkeyvaluestore`.
        orderBy: [PluginkeyvaluestoresOrderBy!] = [PRIMARY_KEY_ASC]
    ): PluginkeyvaluestoresConnection
    post(id: String!): Post
    "Reads a single `Post` using its globally unique `ID`."
    postByNodeId(
        #The globally unique `ID` to be used in selecting a single `Post`.
        nodeId: ID!
    ): Post
    "Reads and enables pagination through a set of `Post`."
    posts(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: PostCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Post`.
        orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PostsConnection
    preference(category: String!, name: String!, userid: String!): Preference
    "Reads a single `Preference` using its globally unique `ID`."
    preferenceByNodeId(
        #The globally unique `ID` to be used in selecting a single `Preference`.
        nodeId: ID!
    ): Preference
    "Reads and enables pagination through a set of `Preference`."
    preferences(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: PreferenceCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Preference`.
        orderBy: [PreferencesOrderBy!] = [PRIMARY_KEY_ASC]
    ): PreferencesConnection
    publicchannel(id: String!): Publicchannel
    publicchannelByNameAndTeamid(name: String!, teamid: String!): Publicchannel
    "Reads a single `Publicchannel` using its globally unique `ID`."
    publicchannelByNodeId(
        #The globally unique `ID` to be used in selecting a single `Publicchannel`.
        nodeId: ID!
    ): Publicchannel
    "Reads and enables pagination through a set of `Publicchannel`."
    publicchannels(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: PublicchannelCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Publicchannel`.
        orderBy: [PublicchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PublicchannelsConnection
    "Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form."
    query: Query!
    reaction(emojiname: String!, postid: String!, userid: String!): Reaction
    "Reads a single `Reaction` using its globally unique `ID`."
    reactionByNodeId(
        #The globally unique `ID` to be used in selecting a single `Reaction`.
        nodeId: ID!
    ): Reaction
    "Reads and enables pagination through a set of `Reaction`."
    reactions(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ReactionCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Reaction`.
        orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ReactionsConnection
    role(id: String!): Role
    roleByName(name: String!): Role
    "Reads a single `Role` using its globally unique `ID`."
    roleByNodeId(
        #The globally unique `ID` to be used in selecting a single `Role`.
        nodeId: ID!
    ): Role
    "Reads and enables pagination through a set of `Role`."
    roles(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: RoleCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Role`.
        orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RolesConnection
    scheme(id: String!): Scheme
    schemeByName(name: String!): Scheme
    "Reads a single `Scheme` using its globally unique `ID`."
    schemeByNodeId(
        #The globally unique `ID` to be used in selecting a single `Scheme`.
        nodeId: ID!
    ): Scheme
    "Reads and enables pagination through a set of `Scheme`."
    schemes(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: SchemeCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Scheme`.
        orderBy: [SchemesOrderBy!] = [PRIMARY_KEY_ASC]
    ): SchemesConnection
    session(id: String!): Session
    "Reads a single `Session` using its globally unique `ID`."
    sessionByNodeId(
        #The globally unique `ID` to be used in selecting a single `Session`.
        nodeId: ID!
    ): Session
    "Reads and enables pagination through a set of `Session`."
    sessions(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: SessionCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Session`.
        orderBy: [SessionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SessionsConnection
    status(userid: String!): Status
    "Reads a single `Status` using its globally unique `ID`."
    statusByNodeId(
        #The globally unique `ID` to be used in selecting a single `Status`.
        nodeId: ID!
    ): Status
    "Reads and enables pagination through a set of `Status`."
    statuses(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: StatusCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Status`.
        orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StatusesConnection
    system(name: String!): System
    "Reads a single `System` using its globally unique `ID`."
    systemByNodeId(
        #The globally unique `ID` to be used in selecting a single `System`.
        nodeId: ID!
    ): System
    "Reads and enables pagination through a set of `System`."
    systems(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: SystemCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `System`.
        orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SystemsConnection
    team(id: String!): Team
    teamByName(name: String!): Team
    "Reads a single `Team` using its globally unique `ID`."
    teamByNodeId(
        #The globally unique `ID` to be used in selecting a single `Team`.
        nodeId: ID!
    ): Team
    teammember(teamid: String!, userid: String!): Teammember
    "Reads a single `Teammember` using its globally unique `ID`."
    teammemberByNodeId(
        #The globally unique `ID` to be used in selecting a single `Teammember`.
        nodeId: ID!
    ): Teammember
    "Reads and enables pagination through a set of `Teammember`."
    teammembers(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: TeammemberCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Teammember`.
        orderBy: [TeammembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeammembersConnection
    "Reads and enables pagination through a set of `Team`."
    teams(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: TeamCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Team`.
        orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeamsConnection
    termsofservice(id: String!): Termsofservice
    "Reads a single `Termsofservice` using its globally unique `ID`."
    termsofserviceByNodeId(
        #The globally unique `ID` to be used in selecting a single `Termsofservice`.
        nodeId: ID!
    ): Termsofservice
    "Reads and enables pagination through a set of `Termsofservice`."
    termsofservices(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: TermsofserviceCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Termsofservice`.
        orderBy: [TermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): TermsofservicesConnection
    token(token: String!): Token
    "Reads a single `Token` using its globally unique `ID`."
    tokenByNodeId(
        #The globally unique `ID` to be used in selecting a single `Token`.
        nodeId: ID!
    ): Token
    "Reads and enables pagination through a set of `Token`."
    tokens(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: TokenCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Token`.
        orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): TokensConnection
    user(id: String!): User
    userByAuthdata(authdata: String!): User
    userByEmail(email: String!): User
    "Reads a single `User` using its globally unique `ID`."
    userByNodeId(
        #The globally unique `ID` to be used in selecting a single `User`.
        nodeId: ID!
    ): User
    userByUsername(username: String!): User
    useraccesstoken(id: String!): Useraccesstoken
    "Reads a single `Useraccesstoken` using its globally unique `ID`."
    useraccesstokenByNodeId(
        #The globally unique `ID` to be used in selecting a single `Useraccesstoken`.
        nodeId: ID!
    ): Useraccesstoken
    useraccesstokenByToken(token: String!): Useraccesstoken
    "Reads and enables pagination through a set of `Useraccesstoken`."
    useraccesstokens(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: UseraccesstokenCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Useraccesstoken`.
        orderBy: [UseraccesstokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): UseraccesstokensConnection
    usergroup(id: String!): Usergroup
    usergroupByName(name: String!): Usergroup
    "Reads a single `Usergroup` using its globally unique `ID`."
    usergroupByNodeId(
        #The globally unique `ID` to be used in selecting a single `Usergroup`.
        nodeId: ID!
    ): Usergroup
    usergroupBySourceAndRemoteid(remoteid: String!, source: String!): Usergroup
    "Reads and enables pagination through a set of `Usergroup`."
    usergroups(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: UsergroupCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Usergroup`.
        orderBy: [UsergroupsOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsergroupsConnection
    "Reads and enables pagination through a set of `User`."
    users(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: UserCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersConnection
    usertermsofservice(userid: String!): Usertermsofservice
    "Reads a single `Usertermsofservice` using its globally unique `ID`."
    usertermsofserviceByNodeId(
        #The globally unique `ID` to be used in selecting a single `Usertermsofservice`.
        nodeId: ID!
    ): Usertermsofservice
    "Reads and enables pagination through a set of `Usertermsofservice`."
    usertermsofservices(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: UsertermsofserviceCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Usertermsofservice`.
        orderBy: [UsertermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsertermsofservicesConnection
}

type Reaction implements Node {
    createat: BigInt
    emojiname: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    postid: String!
    userid: String!
}

"A connection to a list of `Reaction` values."
type ReactionsConnection {
    "A list of edges which contains the `Reaction` and cursor to aid in pagination."
    edges: [ReactionsEdge!]!
    "A list of `Reaction` objects."
    nodes: [Reaction]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Reaction` you could get from the connection."
    totalCount: Int!
}

"A `Reaction` edge in the connection."
type ReactionsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Reaction` at the end of the edge."
    node: Reaction
}

type Role implements Node {
    builtin: Boolean
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    id: String!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    permissions: String
    schememanaged: Boolean
    updateat: BigInt
}

"A connection to a list of `Role` values."
type RolesConnection {
    "A list of edges which contains the `Role` and cursor to aid in pagination."
    edges: [RolesEdge!]!
    "A list of `Role` objects."
    nodes: [Role]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Role` you could get from the connection."
    totalCount: Int!
}

"A `Role` edge in the connection."
type RolesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Role` at the end of the edge."
    node: Role
}

type Scheme implements Node {
    createat: BigInt
    defaultchanneladminrole: String
    defaultchannelguestrole: String
    defaultchanneluserrole: String
    defaultteamadminrole: String
    defaultteamguestrole: String
    defaultteamuserrole: String
    deleteat: BigInt
    description: String
    displayname: String
    id: String!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    scope: String
    updateat: BigInt
}

"A connection to a list of `Scheme` values."
type SchemesConnection {
    "A list of edges which contains the `Scheme` and cursor to aid in pagination."
    edges: [SchemesEdge!]!
    "A list of `Scheme` objects."
    nodes: [Scheme]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Scheme` you could get from the connection."
    totalCount: Int!
}

"A `Scheme` edge in the connection."
type SchemesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Scheme` at the end of the edge."
    node: Scheme
}

type Session implements Node {
    createat: BigInt
    deviceid: String
    expiresat: BigInt
    id: String!
    isoauth: Boolean
    lastactivityat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    props: String
    roles: String
    token: String
    userid: String
}

"A connection to a list of `Session` values."
type SessionsConnection {
    "A list of edges which contains the `Session` and cursor to aid in pagination."
    edges: [SessionsEdge!]!
    "A list of `Session` objects."
    nodes: [Session]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Session` you could get from the connection."
    totalCount: Int!
}

"A `Session` edge in the connection."
type SessionsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Session` at the end of the edge."
    node: Session
}

type Status implements Node {
    lastactivityat: BigInt
    manual: Boolean
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    status: String
    userid: String!
}

"A connection to a list of `Status` values."
type StatusesConnection {
    "A list of edges which contains the `Status` and cursor to aid in pagination."
    edges: [StatusesEdge!]!
    "A list of `Status` objects."
    nodes: [Status]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Status` you could get from the connection."
    totalCount: Int!
}

"A `Status` edge in the connection."
type StatusesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Status` at the end of the edge."
    node: Status
}

type System implements Node {
    name: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    value: String
}

"A connection to a list of `System` values."
type SystemsConnection {
    "A list of edges which contains the `System` and cursor to aid in pagination."
    edges: [SystemsEdge!]!
    "A list of `System` objects."
    nodes: [System]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `System` you could get from the connection."
    totalCount: Int!
}

"A `System` edge in the connection."
type SystemsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `System` at the end of the edge."
    node: System
}

type Team implements Node {
    alloweddomains: String
    allowopeninvite: Boolean
    companyname: String
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    email: String
    groupconstrained: Boolean
    id: String!
    inviteid: String
    lastteamiconupdate: BigInt
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    schemeid: String
    type: String
    updateat: BigInt
}

type Teammember implements Node {
    deleteat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    roles: String
    schemeadmin: Boolean
    schemeguest: Boolean
    schemeuser: Boolean
    teamid: String!
    userid: String!
}

"A connection to a list of `Teammember` values."
type TeammembersConnection {
    "A list of edges which contains the `Teammember` and cursor to aid in pagination."
    edges: [TeammembersEdge!]!
    "A list of `Teammember` objects."
    nodes: [Teammember]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Teammember` you could get from the connection."
    totalCount: Int!
}

"A `Teammember` edge in the connection."
type TeammembersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Teammember` at the end of the edge."
    node: Teammember
}

"A connection to a list of `Team` values."
type TeamsConnection {
    "A list of edges which contains the `Team` and cursor to aid in pagination."
    edges: [TeamsEdge!]!
    "A list of `Team` objects."
    nodes: [Team]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Team` you could get from the connection."
    totalCount: Int!
}

"A `Team` edge in the connection."
type TeamsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Team` at the end of the edge."
    node: Team
}

type Termsofservice implements Node {
    createat: BigInt
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    text: String
    userid: String
}

"A connection to a list of `Termsofservice` values."
type TermsofservicesConnection {
    "A list of edges which contains the `Termsofservice` and cursor to aid in pagination."
    edges: [TermsofservicesEdge!]!
    "A list of `Termsofservice` objects."
    nodes: [Termsofservice]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Termsofservice` you could get from the connection."
    totalCount: Int!
}

"A `Termsofservice` edge in the connection."
type TermsofservicesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Termsofservice` at the end of the edge."
    node: Termsofservice
}

type Token implements Node {
    createat: BigInt
    extra: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    token: String!
    type: String
}

"A connection to a list of `Token` values."
type TokensConnection {
    "A list of edges which contains the `Token` and cursor to aid in pagination."
    edges: [TokensEdge!]!
    "A list of `Token` objects."
    nodes: [Token]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Token` you could get from the connection."
    totalCount: Int!
}

"A `Token` edge in the connection."
type TokensEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Token` at the end of the edge."
    node: Token
}

"The output of our update `Audit` mutation."
type UpdateAuditPayload {
    "The `Audit` that was updated by this mutation."
    audit: Audit
    "An edge for our `Audit`. May be used by Relay 1."
    auditEdge(
        #The method to use when ordering `Audit`.
        orderBy: [AuditsOrderBy!] = [PRIMARY_KEY_ASC]
    ): AuditsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Bot` mutation."
type UpdateBotPayload {
    "The `Bot` that was updated by this mutation."
    bot: Bot
    "An edge for our `Bot`. May be used by Relay 1."
    botEdge(
        #The method to use when ordering `Bot`.
        orderBy: [BotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): BotsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Channel` mutation."
type UpdateChannelPayload {
    "The `Channel` that was updated by this mutation."
    channel: Channel
    "An edge for our `Channel`. May be used by Relay 1."
    channelEdge(
        #The method to use when ordering `Channel`.
        orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelsEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Channelmember` mutation."
type UpdateChannelmemberPayload {
    "The `Channelmember` that was updated by this mutation."
    channelmember: Channelmember
    "An edge for our `Channelmember`. May be used by Relay 1."
    channelmemberEdge(
        #The method to use when ordering `Channelmember`.
        orderBy: [ChannelmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmembersEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Channelmember`."
    userByUserid: User
}

"The output of our update `Channelmemberhistory` mutation."
type UpdateChannelmemberhistoryPayload {
    "The `Channelmemberhistory` that was updated by this mutation."
    channelmemberhistory: Channelmemberhistory
    "An edge for our `Channelmemberhistory`. May be used by Relay 1."
    channelmemberhistoryEdge(
        #The method to use when ordering `Channelmemberhistory`.
        orderBy: [ChannelmemberhistoriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmemberhistoriesEdge
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Clusterdiscovery` mutation."
type UpdateClusterdiscoveryPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Clusterdiscovery` that was updated by this mutation."
    clusterdiscovery: Clusterdiscovery
    "An edge for our `Clusterdiscovery`. May be used by Relay 1."
    clusterdiscoveryEdge(
        #The method to use when ordering `Clusterdiscovery`.
        orderBy: [ClusterdiscoveriesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClusterdiscoveriesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Command` mutation."
type UpdateCommandPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Command` that was updated by this mutation."
    command: Command
    "An edge for our `Command`. May be used by Relay 1."
    commandEdge(
        #The method to use when ordering `Command`.
        orderBy: [CommandsOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Commandwebhook` mutation."
type UpdateCommandwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Commandwebhook` that was updated by this mutation."
    commandwebhook: Commandwebhook
    "An edge for our `Commandwebhook`. May be used by Relay 1."
    commandwebhookEdge(
        #The method to use when ordering `Commandwebhook`.
        orderBy: [CommandwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): CommandwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Compliance` mutation."
type UpdateCompliancePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Compliance` that was updated by this mutation."
    compliance: Compliance
    "An edge for our `Compliance`. May be used by Relay 1."
    complianceEdge(
        #The method to use when ordering `Compliance`.
        orderBy: [CompliancesOrderBy!] = [PRIMARY_KEY_ASC]
    ): CompliancesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Emoji` mutation."
type UpdateEmojiPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Emoji` that was updated by this mutation."
    emoji: Emoji
    "An edge for our `Emoji`. May be used by Relay 1."
    emojiEdge(
        #The method to use when ordering `Emoji`.
        orderBy: [EmojisOrderBy!] = [PRIMARY_KEY_ASC]
    ): EmojisEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Fileinfo` mutation."
type UpdateFileinfoPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Fileinfo` that was updated by this mutation."
    fileinfo: Fileinfo
    "An edge for our `Fileinfo`. May be used by Relay 1."
    fileinfoEdge(
        #The method to use when ordering `Fileinfo`.
        orderBy: [FileinfosOrderBy!] = [PRIMARY_KEY_ASC]
    ): FileinfosEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Groupchannel` mutation."
type UpdateGroupchannelPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Groupchannel` that was updated by this mutation."
    groupchannel: Groupchannel
    "An edge for our `Groupchannel`. May be used by Relay 1."
    groupchannelEdge(
        #The method to use when ordering `Groupchannel`.
        orderBy: [GroupchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupchannelsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Groupmember` mutation."
type UpdateGroupmemberPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Groupmember` that was updated by this mutation."
    groupmember: Groupmember
    "An edge for our `Groupmember`. May be used by Relay 1."
    groupmemberEdge(
        #The method to use when ordering `Groupmember`.
        orderBy: [GroupmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupmembersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Groupteam` mutation."
type UpdateGroupteamPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Groupteam` that was updated by this mutation."
    groupteam: Groupteam
    "An edge for our `Groupteam`. May be used by Relay 1."
    groupteamEdge(
        #The method to use when ordering `Groupteam`.
        orderBy: [GroupteamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): GroupteamsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Incomingwebhook` mutation."
type UpdateIncomingwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Incomingwebhook` that was updated by this mutation."
    incomingwebhook: Incomingwebhook
    "An edge for our `Incomingwebhook`. May be used by Relay 1."
    incomingwebhookEdge(
        #The method to use when ordering `Incomingwebhook`.
        orderBy: [IncomingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): IncomingwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Job` mutation."
type UpdateJobPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Job` that was updated by this mutation."
    job: Job
    "An edge for our `Job`. May be used by Relay 1."
    jobEdge(
        #The method to use when ordering `Job`.
        orderBy: [JobsOrderBy!] = [PRIMARY_KEY_ASC]
    ): JobsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `License` mutation."
type UpdateLicensePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `License` that was updated by this mutation."
    license: License
    "An edge for our `License`. May be used by Relay 1."
    licenseEdge(
        #The method to use when ordering `License`.
        orderBy: [LicensesOrderBy!] = [PRIMARY_KEY_ASC]
    ): LicensesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Linkmetadatum` mutation."
type UpdateLinkmetadatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Linkmetadatum` that was updated by this mutation."
    linkmetadatum: Linkmetadatum
    "An edge for our `Linkmetadatum`. May be used by Relay 1."
    linkmetadatumEdge(
        #The method to use when ordering `Linkmetadatum`.
        orderBy: [LinkmetadataOrderBy!] = [PRIMARY_KEY_ASC]
    ): LinkmetadataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Oauthaccessdatum` mutation."
type UpdateOauthaccessdatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Oauthaccessdatum` that was updated by this mutation."
    oauthaccessdatum: Oauthaccessdatum
    "An edge for our `Oauthaccessdatum`. May be used by Relay 1."
    oauthaccessdatumEdge(
        #The method to use when ordering `Oauthaccessdatum`.
        orderBy: [OauthaccessdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthaccessdataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Oauthapp` mutation."
type UpdateOauthappPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Oauthapp` that was updated by this mutation."
    oauthapp: Oauthapp
    "An edge for our `Oauthapp`. May be used by Relay 1."
    oauthappEdge(
        #The method to use when ordering `Oauthapp`.
        orderBy: [OauthappsOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthappsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Oauthauthdatum` mutation."
type UpdateOauthauthdatumPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Oauthauthdatum` that was updated by this mutation."
    oauthauthdatum: Oauthauthdatum
    "An edge for our `Oauthauthdatum`. May be used by Relay 1."
    oauthauthdatumEdge(
        #The method to use when ordering `Oauthauthdatum`.
        orderBy: [OauthauthdataOrderBy!] = [PRIMARY_KEY_ASC]
    ): OauthauthdataEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Outgoingwebhook` mutation."
type UpdateOutgoingwebhookPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Outgoingwebhook` that was updated by this mutation."
    outgoingwebhook: Outgoingwebhook
    "An edge for our `Outgoingwebhook`. May be used by Relay 1."
    outgoingwebhookEdge(
        #The method to use when ordering `Outgoingwebhook`.
        orderBy: [OutgoingwebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    ): OutgoingwebhooksEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Pluginkeyvaluestore` mutation."
type UpdatePluginkeyvaluestorePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Pluginkeyvaluestore` that was updated by this mutation."
    pluginkeyvaluestore: Pluginkeyvaluestore
    "An edge for our `Pluginkeyvaluestore`. May be used by Relay 1."
    pluginkeyvaluestoreEdge(
        #The method to use when ordering `Pluginkeyvaluestore`.
        orderBy: [PluginkeyvaluestoresOrderBy!] = [PRIMARY_KEY_ASC]
    ): PluginkeyvaluestoresEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Post` mutation."
type UpdatePostPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Post` that was updated by this mutation."
    post: Post
    "An edge for our `Post`. May be used by Relay 1."
    postEdge(
        #The method to use when ordering `Post`.
        orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PostsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Post`."
    user: User
}

"The output of our update `Preference` mutation."
type UpdatePreferencePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Preference` that was updated by this mutation."
    preference: Preference
    "An edge for our `Preference`. May be used by Relay 1."
    preferenceEdge(
        #The method to use when ordering `Preference`.
        orderBy: [PreferencesOrderBy!] = [PRIMARY_KEY_ASC]
    ): PreferencesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Publicchannel` mutation."
type UpdatePublicchannelPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Publicchannel` that was updated by this mutation."
    publicchannel: Publicchannel
    "An edge for our `Publicchannel`. May be used by Relay 1."
    publicchannelEdge(
        #The method to use when ordering `Publicchannel`.
        orderBy: [PublicchannelsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PublicchannelsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `Reaction` mutation."
type UpdateReactionPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Reaction` that was updated by this mutation."
    reaction: Reaction
    "An edge for our `Reaction`. May be used by Relay 1."
    reactionEdge(
        #The method to use when ordering `Reaction`.
        orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ReactionsEdge
}

"The output of our update `Role` mutation."
type UpdateRolePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Role` that was updated by this mutation."
    role: Role
    "An edge for our `Role`. May be used by Relay 1."
    roleEdge(
        #The method to use when ordering `Role`.
        orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RolesEdge
}

"The output of our update `Scheme` mutation."
type UpdateSchemePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Scheme` that was updated by this mutation."
    scheme: Scheme
    "An edge for our `Scheme`. May be used by Relay 1."
    schemeEdge(
        #The method to use when ordering `Scheme`.
        orderBy: [SchemesOrderBy!] = [PRIMARY_KEY_ASC]
    ): SchemesEdge
}

"The output of our update `Session` mutation."
type UpdateSessionPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Session` that was updated by this mutation."
    session: Session
    "An edge for our `Session`. May be used by Relay 1."
    sessionEdge(
        #The method to use when ordering `Session`.
        orderBy: [SessionsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SessionsEdge
}

"The output of our update `Status` mutation."
type UpdateStatusPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Status` that was updated by this mutation."
    status: Status
    "An edge for our `Status`. May be used by Relay 1."
    statusEdge(
        #The method to use when ordering `Status`.
        orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StatusesEdge
}

"The output of our update `System` mutation."
type UpdateSystemPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `System` that was updated by this mutation."
    system: System
    "An edge for our `System`. May be used by Relay 1."
    systemEdge(
        #The method to use when ordering `System`.
        orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SystemsEdge
}

"The output of our update `Team` mutation."
type UpdateTeamPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Team` that was updated by this mutation."
    team: Team
    "An edge for our `Team`. May be used by Relay 1."
    teamEdge(
        #The method to use when ordering `Team`.
        orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeamsEdge
}

"The output of our update `Teammember` mutation."
type UpdateTeammemberPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Teammember` that was updated by this mutation."
    teammember: Teammember
    "An edge for our `Teammember`. May be used by Relay 1."
    teammemberEdge(
        #The method to use when ordering `Teammember`.
        orderBy: [TeammembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): TeammembersEdge
}

"The output of our update `Termsofservice` mutation."
type UpdateTermsofservicePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Termsofservice` that was updated by this mutation."
    termsofservice: Termsofservice
    "An edge for our `Termsofservice`. May be used by Relay 1."
    termsofserviceEdge(
        #The method to use when ordering `Termsofservice`.
        orderBy: [TermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): TermsofservicesEdge
}

"The output of our update `Token` mutation."
type UpdateTokenPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Token` that was updated by this mutation."
    token: Token
    "An edge for our `Token`. May be used by Relay 1."
    tokenEdge(
        #The method to use when ordering `Token`.
        orderBy: [TokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): TokensEdge
}

"The output of our update `User` mutation."
type UpdateUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was updated by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

"The output of our update `Useraccesstoken` mutation."
type UpdateUseraccesstokenPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Useraccesstoken` that was updated by this mutation."
    useraccesstoken: Useraccesstoken
    "An edge for our `Useraccesstoken`. May be used by Relay 1."
    useraccesstokenEdge(
        #The method to use when ordering `Useraccesstoken`.
        orderBy: [UseraccesstokensOrderBy!] = [PRIMARY_KEY_ASC]
    ): UseraccesstokensEdge
}

"The output of our update `Usergroup` mutation."
type UpdateUsergroupPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Usergroup` that was updated by this mutation."
    usergroup: Usergroup
    "An edge for our `Usergroup`. May be used by Relay 1."
    usergroupEdge(
        #The method to use when ordering `Usergroup`.
        orderBy: [UsergroupsOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsergroupsEdge
}

"The output of our update `Usertermsofservice` mutation."
type UpdateUsertermsofservicePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Usertermsofservice` that was updated by this mutation."
    usertermsofservice: Usertermsofservice
    "An edge for our `Usertermsofservice`. May be used by Relay 1."
    usertermsofserviceEdge(
        #The method to use when ordering `Usertermsofservice`.
        orderBy: [UsertermsofservicesOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsertermsofservicesEdge
}

type User implements Node {
    allowmarketing: Boolean
    authdata: String
    authservice: String
    "Reads and enables pagination through a set of `Channelmember`."
    channelmembersByUserid(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: ChannelmemberCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Channelmember`.
        orderBy: [ChannelmembersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ChannelmembersConnection!
    createat: BigInt
    deleteat: BigInt
    email: String
    emailverified: Boolean
    failedattempts: Int
    firstname: String
    id: String!
    lastname: String
    lastpasswordupdate: BigInt
    lastpictureupdate: BigInt
    locale: String
    mfaactive: Boolean
    mfasecret: String
    nickname: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    notifyprops: String
    password: String
    position: String
    "Reads and enables pagination through a set of `Post`."
    posts(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: PostCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Post`.
        orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
    ): PostsConnection!
    props: String
    roles: String
    timezone: String
    updateat: BigInt
    username: String
}

type Useraccesstoken implements Node {
    description: String
    id: String!
    isactive: Boolean
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    token: String
    userid: String
}

"A connection to a list of `Useraccesstoken` values."
type UseraccesstokensConnection {
    "A list of edges which contains the `Useraccesstoken` and cursor to aid in pagination."
    edges: [UseraccesstokensEdge!]!
    "A list of `Useraccesstoken` objects."
    nodes: [Useraccesstoken]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Useraccesstoken` you could get from the connection."
    totalCount: Int!
}

"A `Useraccesstoken` edge in the connection."
type UseraccesstokensEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Useraccesstoken` at the end of the edge."
    node: Useraccesstoken
}

type Usergroup implements Node {
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    id: String!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    remoteid: String
    source: String
    updateat: BigInt
}

"A connection to a list of `Usergroup` values."
type UsergroupsConnection {
    "A list of edges which contains the `Usergroup` and cursor to aid in pagination."
    edges: [UsergroupsEdge!]!
    "A list of `Usergroup` objects."
    nodes: [Usergroup]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Usergroup` you could get from the connection."
    totalCount: Int!
}

"A `Usergroup` edge in the connection."
type UsergroupsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Usergroup` at the end of the edge."
    node: Usergroup
}

"A connection to a list of `User` values."
type UsersConnection {
    "A list of edges which contains the `User` and cursor to aid in pagination."
    edges: [UsersEdge!]!
    "A list of `User` objects."
    nodes: [User]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `User` you could get from the connection."
    totalCount: Int!
}

"A `User` edge in the connection."
type UsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `User` at the end of the edge."
    node: User
}

type Usertermsofservice implements Node {
    createat: BigInt
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    termsofserviceid: String
    userid: String!
}

"A connection to a list of `Usertermsofservice` values."
type UsertermsofservicesConnection {
    "A list of edges which contains the `Usertermsofservice` and cursor to aid in pagination."
    edges: [UsertermsofservicesEdge!]!
    "A list of `Usertermsofservice` objects."
    nodes: [Usertermsofservice]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Usertermsofservice` you could get from the connection."
    totalCount: Int!
}

"A `Usertermsofservice` edge in the connection."
type UsertermsofservicesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Usertermsofservice` at the end of the edge."
    node: Usertermsofservice
}

"Methods to use when ordering `Audit`."
enum AuditsOrderBy {
    ACTION_ASC
    ACTION_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    EXTRAINFO_ASC
    EXTRAINFO_DESC
    ID_ASC
    ID_DESC
    IPADDRESS_ASC
    IPADDRESS_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SESSIONID_ASC
    SESSIONID_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Bot`."
enum BotsOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    LASTICONUPDATE_ASC
    LASTICONUPDATE_DESC
    NATURAL
    OWNERID_ASC
    OWNERID_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Channelmemberhistory`."
enum ChannelmemberhistoriesOrderBy {
    CHANNELID_ASC
    CHANNELID_DESC
    JOINTIME_ASC
    JOINTIME_DESC
    LEAVETIME_ASC
    LEAVETIME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Channelmember`."
enum ChannelmembersOrderBy {
    CHANNELID_ASC
    CHANNELID_DESC
    LASTUPDATEAT_ASC
    LASTUPDATEAT_DESC
    LASTVIEWEDAT_ASC
    LASTVIEWEDAT_DESC
    MENTIONCOUNT_ASC
    MENTIONCOUNT_DESC
    MSGCOUNT_ASC
    MSGCOUNT_DESC
    NATURAL
    NOTIFYPROPS_ASC
    NOTIFYPROPS_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    ROLES_ASC
    ROLES_DESC
    SCHEMEADMIN_ASC
    SCHEMEADMIN_DESC
    SCHEMEGUEST_ASC
    SCHEMEGUEST_DESC
    SCHEMEUSER_ASC
    SCHEMEUSER_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Channel`."
enum ChannelsOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    CREATORID_ASC
    CREATORID_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    EXTRAUPDATEAT_ASC
    EXTRAUPDATEAT_DESC
    GROUPCONSTRAINED_ASC
    GROUPCONSTRAINED_DESC
    HEADER_ASC
    HEADER_DESC
    ID_ASC
    ID_DESC
    LASTPOSTAT_ASC
    LASTPOSTAT_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PURPOSE_ASC
    PURPOSE_DESC
    SCHEMEID_ASC
    SCHEMEID_DESC
    TEAMID_ASC
    TEAMID_DESC
    TOTALMSGCOUNT_ASC
    TOTALMSGCOUNT_DESC
    TYPE_ASC
    TYPE_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Clusterdiscovery`."
enum ClusterdiscoveriesOrderBy {
    CLUSTERNAME_ASC
    CLUSTERNAME_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    GOSSIPPORT_ASC
    GOSSIPPORT_DESC
    HOSTNAME_ASC
    HOSTNAME_DESC
    ID_ASC
    ID_DESC
    LASTPINGAT_ASC
    LASTPINGAT_DESC
    NATURAL
    PORT_ASC
    PORT_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TYPE_ASC
    TYPE_DESC
}

"Methods to use when ordering `Command`."
enum CommandsOrderBy {
    AUTOCOMPLETEDESC_ASC
    AUTOCOMPLETEDESC_DESC
    AUTOCOMPLETEHINT_ASC
    AUTOCOMPLETEHINT_DESC
    AUTOCOMPLETE_ASC
    AUTOCOMPLETE_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    CREATORID_ASC
    CREATORID_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    ICONURL_ASC
    ICONURL_DESC
    ID_ASC
    ID_DESC
    METHOD_ASC
    METHOD_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TEAMID_ASC
    TEAMID_DESC
    TOKEN_ASC
    TOKEN_DESC
    TRIGGER_ASC
    TRIGGER_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    URL_ASC
    URL_DESC
    USERNAME_ASC
    USERNAME_DESC
}

"Methods to use when ordering `Commandwebhook`."
enum CommandwebhooksOrderBy {
    CHANNELID_ASC
    CHANNELID_DESC
    COMMANDID_ASC
    COMMANDID_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PARENTID_ASC
    PARENTID_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    ROOTID_ASC
    ROOTID_DESC
    USECOUNT_ASC
    USECOUNT_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Compliance`."
enum CompliancesOrderBy {
    COUNT_ASC
    COUNT_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DESC_ASC
    DESC_DESC
    EMAILS_ASC
    EMAILS_DESC
    ENDAT_ASC
    ENDAT_DESC
    ID_ASC
    ID_DESC
    KEYWORDS_ASC
    KEYWORDS_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STARTAT_ASC
    STARTAT_DESC
    STATUS_ASC
    STATUS_DESC
    TYPE_ASC
    TYPE_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Emoji`."
enum EmojisOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    CREATORID_ASC
    CREATORID_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    ID_ASC
    ID_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Fileinfo`."
enum FileinfosOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    CREATORID_ASC
    CREATORID_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    EXTENSION_ASC
    EXTENSION_DESC
    HASPREVIEWIMAGE_ASC
    HASPREVIEWIMAGE_DESC
    HEIGHT_ASC
    HEIGHT_DESC
    ID_ASC
    ID_DESC
    MIMETYPE_ASC
    MIMETYPE_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PATH_ASC
    PATH_DESC
    POSTID_ASC
    POSTID_DESC
    PREVIEWPATH_ASC
    PREVIEWPATH_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SIZE_ASC
    SIZE_DESC
    THUMBNAILPATH_ASC
    THUMBNAILPATH_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    WIDTH_ASC
    WIDTH_DESC
}

"Methods to use when ordering `Groupchannel`."
enum GroupchannelsOrderBy {
    AUTOADD_ASC
    AUTOADD_DESC
    CHANNELID_ASC
    CHANNELID_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    GROUPID_ASC
    GROUPID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SCHEMEADMIN_ASC
    SCHEMEADMIN_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Groupmember`."
enum GroupmembersOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    GROUPID_ASC
    GROUPID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Groupteam`."
enum GroupteamsOrderBy {
    AUTOADD_ASC
    AUTOADD_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    GROUPID_ASC
    GROUPID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SCHEMEADMIN_ASC
    SCHEMEADMIN_DESC
    TEAMID_ASC
    TEAMID_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Incomingwebhook`."
enum IncomingwebhooksOrderBy {
    CHANNELID_ASC
    CHANNELID_DESC
    CHANNELLOCKED_ASC
    CHANNELLOCKED_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    ICONURL_ASC
    ICONURL_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TEAMID_ASC
    TEAMID_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    USERID_ASC
    USERID_DESC
    USERNAME_ASC
    USERNAME_DESC
}

"Methods to use when ordering `Job`."
enum JobsOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    DATA_ASC
    DATA_DESC
    ID_ASC
    ID_DESC
    LASTACTIVITYAT_ASC
    LASTACTIVITYAT_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PRIORITY_ASC
    PRIORITY_DESC
    PROGRESS_ASC
    PROGRESS_DESC
    STARTAT_ASC
    STARTAT_DESC
    STATUS_ASC
    STATUS_DESC
    TYPE_ASC
    TYPE_DESC
}

"Methods to use when ordering `License`."
enum LicensesOrderBy {
    BYTES_ASC
    BYTES_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
}

"Methods to use when ordering `Linkmetadatum`."
enum LinkmetadataOrderBy {
    DATA_ASC
    DATA_DESC
    HASH_ASC
    HASH_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TIMESTAMP_ASC
    TIMESTAMP_DESC
    TYPE_ASC
    TYPE_DESC
    URL_ASC
    URL_DESC
}

"Methods to use when ordering `Oauthaccessdatum`."
enum OauthaccessdataOrderBy {
    CLIENTID_ASC
    CLIENTID_DESC
    EXPIRESAT_ASC
    EXPIRESAT_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    REDIRECTURI_ASC
    REDIRECTURI_DESC
    REFRESHTOKEN_ASC
    REFRESHTOKEN_DESC
    SCOPE_ASC
    SCOPE_DESC
    TOKEN_ASC
    TOKEN_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Oauthapp`."
enum OauthappsOrderBy {
    CALLBACKURLS_ASC
    CALLBACKURLS_DESC
    CLIENTSECRET_ASC
    CLIENTSECRET_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    CREATORID_ASC
    CREATORID_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    HOMEPAGE_ASC
    HOMEPAGE_DESC
    ICONURL_ASC
    ICONURL_DESC
    ID_ASC
    ID_DESC
    ISTRUSTED_ASC
    ISTRUSTED_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Oauthauthdatum`."
enum OauthauthdataOrderBy {
    CLIENTID_ASC
    CLIENTID_DESC
    CODE_ASC
    CODE_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    EXPIRESIN_ASC
    EXPIRESIN_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    REDIRECTURI_ASC
    REDIRECTURI_DESC
    SCOPE_ASC
    SCOPE_DESC
    STATE_ASC
    STATE_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Outgoingwebhook`."
enum OutgoingwebhooksOrderBy {
    CALLBACKURLS_ASC
    CALLBACKURLS_DESC
    CHANNELID_ASC
    CHANNELID_DESC
    CONTENTTYPE_ASC
    CONTENTTYPE_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    CREATORID_ASC
    CREATORID_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    ICONURL_ASC
    ICONURL_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TEAMID_ASC
    TEAMID_DESC
    TOKEN_ASC
    TOKEN_DESC
    TRIGGERWHEN_ASC
    TRIGGERWHEN_DESC
    TRIGGERWORDS_ASC
    TRIGGERWORDS_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    USERNAME_ASC
    USERNAME_DESC
}

"Methods to use when ordering `Pluginkeyvaluestore`."
enum PluginkeyvaluestoresOrderBy {
    EXPIREAT_ASC
    EXPIREAT_DESC
    NATURAL
    PKEY_ASC
    PKEY_DESC
    PLUGINID_ASC
    PLUGINID_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PVALUE_ASC
    PVALUE_DESC
}

"Methods to use when ordering `Post`."
enum PostsOrderBy {
    CHANNELID_ASC
    CHANNELID_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    EDITAT_ASC
    EDITAT_DESC
    FILEIDS_ASC
    FILEIDS_DESC
    FILENAMES_ASC
    FILENAMES_DESC
    HASHTAGS_ASC
    HASHTAGS_DESC
    HASREACTIONS_ASC
    HASREACTIONS_DESC
    ID_ASC
    ID_DESC
    ISPINNED_ASC
    ISPINNED_DESC
    MESSAGE_ASC
    MESSAGE_DESC
    NATURAL
    ORIGINALID_ASC
    ORIGINALID_DESC
    PARENTID_ASC
    PARENTID_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PROPS_ASC
    PROPS_DESC
    ROOTID_ASC
    ROOTID_DESC
    TYPE_ASC
    TYPE_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    USER_ID_ASC
    USER_ID_DESC
}

"Methods to use when ordering `Preference`."
enum PreferencesOrderBy {
    CATEGORY_ASC
    CATEGORY_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    USERID_ASC
    USERID_DESC
    VALUE_ASC
    VALUE_DESC
}

"Methods to use when ordering `Publicchannel`."
enum PublicchannelsOrderBy {
    DELETEAT_ASC
    DELETEAT_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    HEADER_ASC
    HEADER_DESC
    ID_ASC
    ID_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PURPOSE_ASC
    PURPOSE_DESC
    TEAMID_ASC
    TEAMID_DESC
}

"Methods to use when ordering `Reaction`."
enum ReactionsOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    EMOJINAME_ASC
    EMOJINAME_DESC
    NATURAL
    POSTID_ASC
    POSTID_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Role`."
enum RolesOrderBy {
    BUILTIN_ASC
    BUILTIN_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    ID_ASC
    ID_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PERMISSIONS_ASC
    PERMISSIONS_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SCHEMEMANAGED_ASC
    SCHEMEMANAGED_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Scheme`."
enum SchemesOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    DEFAULTCHANNELADMINROLE_ASC
    DEFAULTCHANNELADMINROLE_DESC
    DEFAULTCHANNELGUESTROLE_ASC
    DEFAULTCHANNELGUESTROLE_DESC
    DEFAULTCHANNELUSERROLE_ASC
    DEFAULTCHANNELUSERROLE_DESC
    DEFAULTTEAMADMINROLE_ASC
    DEFAULTTEAMADMINROLE_DESC
    DEFAULTTEAMGUESTROLE_ASC
    DEFAULTTEAMGUESTROLE_DESC
    DEFAULTTEAMUSERROLE_ASC
    DEFAULTTEAMUSERROLE_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    ID_ASC
    ID_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SCOPE_ASC
    SCOPE_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Session`."
enum SessionsOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    DEVICEID_ASC
    DEVICEID_DESC
    EXPIRESAT_ASC
    EXPIRESAT_DESC
    ID_ASC
    ID_DESC
    ISOAUTH_ASC
    ISOAUTH_DESC
    LASTACTIVITYAT_ASC
    LASTACTIVITYAT_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PROPS_ASC
    PROPS_DESC
    ROLES_ASC
    ROLES_DESC
    TOKEN_ASC
    TOKEN_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Status`."
enum StatusesOrderBy {
    LASTACTIVITYAT_ASC
    LASTACTIVITYAT_DESC
    MANUAL_ASC
    MANUAL_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STATUS_ASC
    STATUS_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `System`."
enum SystemsOrderBy {
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    VALUE_ASC
    VALUE_DESC
}

"Methods to use when ordering `Teammember`."
enum TeammembersOrderBy {
    DELETEAT_ASC
    DELETEAT_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    ROLES_ASC
    ROLES_DESC
    SCHEMEADMIN_ASC
    SCHEMEADMIN_DESC
    SCHEMEGUEST_ASC
    SCHEMEGUEST_DESC
    SCHEMEUSER_ASC
    SCHEMEUSER_DESC
    TEAMID_ASC
    TEAMID_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Team`."
enum TeamsOrderBy {
    ALLOWEDDOMAINS_ASC
    ALLOWEDDOMAINS_DESC
    ALLOWOPENINVITE_ASC
    ALLOWOPENINVITE_DESC
    COMPANYNAME_ASC
    COMPANYNAME_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    EMAIL_ASC
    EMAIL_DESC
    GROUPCONSTRAINED_ASC
    GROUPCONSTRAINED_DESC
    ID_ASC
    ID_DESC
    INVITEID_ASC
    INVITEID_DESC
    LASTTEAMICONUPDATE_ASC
    LASTTEAMICONUPDATE_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SCHEMEID_ASC
    SCHEMEID_DESC
    TYPE_ASC
    TYPE_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `Termsofservice`."
enum TermsofservicesOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TEXT_ASC
    TEXT_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Token`."
enum TokensOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    EXTRA_ASC
    EXTRA_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TOKEN_ASC
    TOKEN_DESC
    TYPE_ASC
    TYPE_DESC
}

"Methods to use when ordering `Useraccesstoken`."
enum UseraccesstokensOrderBy {
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    ID_ASC
    ID_DESC
    ISACTIVE_ASC
    ISACTIVE_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TOKEN_ASC
    TOKEN_DESC
    USERID_ASC
    USERID_DESC
}

"Methods to use when ordering `Usergroup`."
enum UsergroupsOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    DISPLAYNAME_ASC
    DISPLAYNAME_DESC
    ID_ASC
    ID_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    REMOTEID_ASC
    REMOTEID_DESC
    SOURCE_ASC
    SOURCE_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
}

"Methods to use when ordering `User`."
enum UsersOrderBy {
    ALLOWMARKETING_ASC
    ALLOWMARKETING_DESC
    AUTHDATA_ASC
    AUTHDATA_DESC
    AUTHSERVICE_ASC
    AUTHSERVICE_DESC
    CREATEAT_ASC
    CREATEAT_DESC
    DELETEAT_ASC
    DELETEAT_DESC
    EMAILVERIFIED_ASC
    EMAILVERIFIED_DESC
    EMAIL_ASC
    EMAIL_DESC
    FAILEDATTEMPTS_ASC
    FAILEDATTEMPTS_DESC
    FIRSTNAME_ASC
    FIRSTNAME_DESC
    ID_ASC
    ID_DESC
    LASTNAME_ASC
    LASTNAME_DESC
    LASTPASSWORDUPDATE_ASC
    LASTPASSWORDUPDATE_DESC
    LASTPICTUREUPDATE_ASC
    LASTPICTUREUPDATE_DESC
    LOCALE_ASC
    LOCALE_DESC
    MFAACTIVE_ASC
    MFAACTIVE_DESC
    MFASECRET_ASC
    MFASECRET_DESC
    NATURAL
    NICKNAME_ASC
    NICKNAME_DESC
    NOTIFYPROPS_ASC
    NOTIFYPROPS_DESC
    PASSWORD_ASC
    PASSWORD_DESC
    POSITION_ASC
    POSITION_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    PROPS_ASC
    PROPS_DESC
    ROLES_ASC
    ROLES_DESC
    TIMEZONE_ASC
    TIMEZONE_DESC
    UPDATEAT_ASC
    UPDATEAT_DESC
    USERNAME_ASC
    USERNAME_DESC
}

"Methods to use when ordering `Usertermsofservice`."
enum UsertermsofservicesOrderBy {
    CREATEAT_ASC
    CREATEAT_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TERMSOFSERVICEID_ASC
    TERMSOFSERVICEID_DESC
    USERID_ASC
    USERID_DESC
}

"A condition to be used against `Audit` object types. All fields are tested for equality and combined with a logical and."
input AuditCondition {
    "Checks for equality with the objects `action` field."
    action: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `extrainfo` field."
    extrainfo: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `ipaddress` field."
    ipaddress: String
    "Checks for equality with the objects `sessionid` field."
    sessionid: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Audit`"
input AuditInput {
    action: String
    createat: BigInt
    extrainfo: String
    id: String!
    ipaddress: String
    sessionid: String
    userid: String
}

"Represents an update to a `Audit`. Fields that are set will be updated."
input AuditPatch {
    action: String
    createat: BigInt
    extrainfo: String
    id: String
    ipaddress: String
    sessionid: String
    userid: String
}

"A condition to be used against `Bot` object types. All fields are tested for equality and combined with a logical and."
input BotCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `lasticonupdate` field."
    lasticonupdate: BigInt
    "Checks for equality with the objects `ownerid` field."
    ownerid: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Bot`"
input BotInput {
    createat: BigInt
    deleteat: BigInt
    description: String
    lasticonupdate: BigInt
    ownerid: String
    updateat: BigInt
    userid: String!
}

"Represents an update to a `Bot`. Fields that are set will be updated."
input BotPatch {
    createat: BigInt
    deleteat: BigInt
    description: String
    lasticonupdate: BigInt
    ownerid: String
    updateat: BigInt
    userid: String
}

"A condition to be used against `Channel` object types. All fields are tested for equality and combined with a logical and."
input ChannelCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `creatorid` field."
    creatorid: String
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `extraupdateat` field."
    extraupdateat: BigInt
    "Checks for equality with the objects `groupconstrained` field."
    groupconstrained: Boolean
    "Checks for equality with the objects `header` field."
    header: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `lastpostat` field."
    lastpostat: BigInt
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `purpose` field."
    purpose: String
    "Checks for equality with the objects `schemeid` field."
    schemeid: String
    "Checks for equality with the objects `teamid` field."
    teamid: String
    "Checks for equality with the objects `totalmsgcount` field."
    totalmsgcount: BigInt
    "Checks for equality with the objects `type` field."
    type: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Channel`"
input ChannelInput {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    displayname: String
    extraupdateat: BigInt
    groupconstrained: Boolean
    header: String
    id: String!
    lastpostat: BigInt
    name: String
    purpose: String
    schemeid: String
    teamid: String
    totalmsgcount: BigInt
    type: String
    updateat: BigInt
}

"Represents an update to a `Channel`. Fields that are set will be updated."
input ChannelPatch {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    displayname: String
    extraupdateat: BigInt
    groupconstrained: Boolean
    header: String
    id: String
    lastpostat: BigInt
    name: String
    purpose: String
    schemeid: String
    teamid: String
    totalmsgcount: BigInt
    type: String
    updateat: BigInt
}

"A condition to be used against `Channelmember` object types. All fields are tested for equality and combined with a logical and."
input ChannelmemberCondition {
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `lastupdateat` field."
    lastupdateat: BigInt
    "Checks for equality with the objects `lastviewedat` field."
    lastviewedat: BigInt
    "Checks for equality with the objects `mentioncount` field."
    mentioncount: BigInt
    "Checks for equality with the objects `msgcount` field."
    msgcount: BigInt
    "Checks for equality with the objects `notifyprops` field."
    notifyprops: String
    "Checks for equality with the objects `roles` field."
    roles: String
    "Checks for equality with the objects `schemeadmin` field."
    schemeadmin: Boolean
    "Checks for equality with the objects `schemeguest` field."
    schemeguest: Boolean
    "Checks for equality with the objects `schemeuser` field."
    schemeuser: Boolean
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Channelmember`"
input ChannelmemberInput {
    channelid: String!
    lastupdateat: BigInt
    lastviewedat: BigInt
    mentioncount: BigInt
    msgcount: BigInt
    notifyprops: String
    roles: String
    schemeadmin: Boolean
    schemeguest: Boolean
    schemeuser: Boolean
    userid: String!
}

"Represents an update to a `Channelmember`. Fields that are set will be updated."
input ChannelmemberPatch {
    channelid: String
    lastupdateat: BigInt
    lastviewedat: BigInt
    mentioncount: BigInt
    msgcount: BigInt
    notifyprops: String
    roles: String
    schemeadmin: Boolean
    schemeguest: Boolean
    schemeuser: Boolean
    userid: String
}

"A condition to be used against `Channelmemberhistory` object types. All fields are tested for equality and combined with a logical and."
input ChannelmemberhistoryCondition {
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `jointime` field."
    jointime: BigInt
    "Checks for equality with the objects `leavetime` field."
    leavetime: BigInt
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Channelmemberhistory`"
input ChannelmemberhistoryInput {
    channelid: String!
    jointime: BigInt!
    leavetime: BigInt
    userid: String!
}

"Represents an update to a `Channelmemberhistory`. Fields that are set will be updated."
input ChannelmemberhistoryPatch {
    channelid: String
    jointime: BigInt
    leavetime: BigInt
    userid: String
}

"A condition to be used against `Clusterdiscovery` object types. All fields are tested for equality and combined with a logical and."
input ClusterdiscoveryCondition {
    "Checks for equality with the objects `clustername` field."
    clustername: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `gossipport` field."
    gossipport: Int
    "Checks for equality with the objects `hostname` field."
    hostname: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `lastpingat` field."
    lastpingat: BigInt
    "Checks for equality with the objects `port` field."
    port: Int
    "Checks for equality with the objects `type` field."
    type: String
}

"An input for mutations affecting `Clusterdiscovery`"
input ClusterdiscoveryInput {
    clustername: String
    createat: BigInt
    gossipport: Int
    hostname: String
    id: String!
    lastpingat: BigInt
    port: Int
    type: String
}

"Represents an update to a `Clusterdiscovery`. Fields that are set will be updated."
input ClusterdiscoveryPatch {
    clustername: String
    createat: BigInt
    gossipport: Int
    hostname: String
    id: String
    lastpingat: BigInt
    port: Int
    type: String
}

"A condition to be used against `Command` object types. All fields are tested for equality and combined with a logical and."
input CommandCondition {
    "Checks for equality with the objects `autocomplete` field."
    autocomplete: Boolean
    "Checks for equality with the objects `autocompletedesc` field."
    autocompletedesc: String
    "Checks for equality with the objects `autocompletehint` field."
    autocompletehint: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `creatorid` field."
    creatorid: String
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `iconurl` field."
    iconurl: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `method` field."
    method: String
    "Checks for equality with the objects `teamid` field."
    teamid: String
    "Checks for equality with the objects `token` field."
    token: String
    "Checks for equality with the objects `trigger` field."
    trigger: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `url` field."
    url: String
    "Checks for equality with the objects `username` field."
    username: String
}

"An input for mutations affecting `Command`"
input CommandInput {
    autocomplete: Boolean
    autocompletedesc: String
    autocompletehint: String
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String!
    method: String
    teamid: String
    token: String
    trigger: String
    updateat: BigInt
    url: String
    username: String
}

"Represents an update to a `Command`. Fields that are set will be updated."
input CommandPatch {
    autocomplete: Boolean
    autocompletedesc: String
    autocompletehint: String
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String
    method: String
    teamid: String
    token: String
    trigger: String
    updateat: BigInt
    url: String
    username: String
}

"A condition to be used against `Commandwebhook` object types. All fields are tested for equality and combined with a logical and."
input CommandwebhookCondition {
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `commandid` field."
    commandid: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `parentid` field."
    parentid: String
    "Checks for equality with the objects `rootid` field."
    rootid: String
    "Checks for equality with the objects `usecount` field."
    usecount: Int
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Commandwebhook`"
input CommandwebhookInput {
    channelid: String
    commandid: String
    createat: BigInt
    id: String!
    parentid: String
    rootid: String
    usecount: Int
    userid: String
}

"Represents an update to a `Commandwebhook`. Fields that are set will be updated."
input CommandwebhookPatch {
    channelid: String
    commandid: String
    createat: BigInt
    id: String
    parentid: String
    rootid: String
    usecount: Int
    userid: String
}

"A condition to be used against `Compliance` object types. All fields are tested for equality and combined with a logical and."
input ComplianceCondition {
    "Checks for equality with the objects `count` field."
    count: Int
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `desc` field."
    desc: String
    "Checks for equality with the objects `emails` field."
    emails: String
    "Checks for equality with the objects `endat` field."
    endat: BigInt
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `keywords` field."
    keywords: String
    "Checks for equality with the objects `startat` field."
    startat: BigInt
    "Checks for equality with the objects `status` field."
    status: String
    "Checks for equality with the objects `type` field."
    type: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Compliance`"
input ComplianceInput {
    count: Int
    createat: BigInt
    desc: String
    emails: String
    endat: BigInt
    id: String!
    keywords: String
    startat: BigInt
    status: String
    type: String
    userid: String
}

"Represents an update to a `Compliance`. Fields that are set will be updated."
input CompliancePatch {
    count: Int
    createat: BigInt
    desc: String
    emails: String
    endat: BigInt
    id: String
    keywords: String
    startat: BigInt
    status: String
    type: String
    userid: String
}

"All input for the create `Audit` mutation."
input CreateAuditInput {
    "The `Audit` to be created by this mutation."
    audit: AuditInput!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

"All input for the create `Bot` mutation."
input CreateBotInput {
    "The `Bot` to be created by this mutation."
    bot: BotInput!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

"All input for the create `Channel` mutation."
input CreateChannelInput {
    "The `Channel` to be created by this mutation."
    channel: ChannelInput!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

"All input for the create `Channelmember` mutation."
input CreateChannelmemberInput {
    "The `Channelmember` to be created by this mutation."
    channelmember: ChannelmemberInput!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

"All input for the create `Channelmemberhistory` mutation."
input CreateChannelmemberhistoryInput {
    "The `Channelmemberhistory` to be created by this mutation."
    channelmemberhistory: ChannelmemberhistoryInput!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

"All input for the create `Clusterdiscovery` mutation."
input CreateClusterdiscoveryInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Clusterdiscovery` to be created by this mutation."
    clusterdiscovery: ClusterdiscoveryInput!
}

"All input for the create `Command` mutation."
input CreateCommandInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Command` to be created by this mutation."
    command: CommandInput!
}

"All input for the create `Commandwebhook` mutation."
input CreateCommandwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Commandwebhook` to be created by this mutation."
    commandwebhook: CommandwebhookInput!
}

"All input for the create `Compliance` mutation."
input CreateComplianceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Compliance` to be created by this mutation."
    compliance: ComplianceInput!
}

"All input for the create `Emoji` mutation."
input CreateEmojiInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Emoji` to be created by this mutation."
    emoji: EmojiInput!
}

"All input for the create `Fileinfo` mutation."
input CreateFileinfoInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Fileinfo` to be created by this mutation."
    fileinfo: FileinfoInput!
}

"All input for the create `Groupchannel` mutation."
input CreateGroupchannelInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Groupchannel` to be created by this mutation."
    groupchannel: GroupchannelInput!
}

"All input for the create `Groupmember` mutation."
input CreateGroupmemberInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Groupmember` to be created by this mutation."
    groupmember: GroupmemberInput!
}

"All input for the create `Groupteam` mutation."
input CreateGroupteamInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Groupteam` to be created by this mutation."
    groupteam: GroupteamInput!
}

"All input for the create `Incomingwebhook` mutation."
input CreateIncomingwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Incomingwebhook` to be created by this mutation."
    incomingwebhook: IncomingwebhookInput!
}

"All input for the create `Job` mutation."
input CreateJobInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Job` to be created by this mutation."
    job: JobInput!
}

"All input for the create `License` mutation."
input CreateLicenseInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `License` to be created by this mutation."
    license: LicenseInput!
}

"All input for the create `Linkmetadatum` mutation."
input CreateLinkmetadatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Linkmetadatum` to be created by this mutation."
    linkmetadatum: LinkmetadatumInput!
}

"All input for the create `Oauthaccessdatum` mutation."
input CreateOauthaccessdatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Oauthaccessdatum` to be created by this mutation."
    oauthaccessdatum: OauthaccessdatumInput!
}

"All input for the create `Oauthapp` mutation."
input CreateOauthappInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Oauthapp` to be created by this mutation."
    oauthapp: OauthappInput!
}

"All input for the create `Oauthauthdatum` mutation."
input CreateOauthauthdatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Oauthauthdatum` to be created by this mutation."
    oauthauthdatum: OauthauthdatumInput!
}

"All input for the create `Outgoingwebhook` mutation."
input CreateOutgoingwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Outgoingwebhook` to be created by this mutation."
    outgoingwebhook: OutgoingwebhookInput!
}

"All input for the create `Pluginkeyvaluestore` mutation."
input CreatePluginkeyvaluestoreInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Pluginkeyvaluestore` to be created by this mutation."
    pluginkeyvaluestore: PluginkeyvaluestoreInput!
}

"All input for the create `Post` mutation."
input CreatePostInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Post` to be created by this mutation."
    post: PostInput!
}

"All input for the create `Preference` mutation."
input CreatePreferenceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Preference` to be created by this mutation."
    preference: PreferenceInput!
}

"All input for the create `Publicchannel` mutation."
input CreatePublicchannelInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Publicchannel` to be created by this mutation."
    publicchannel: PublicchannelInput!
}

"All input for the create `Reaction` mutation."
input CreateReactionInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Reaction` to be created by this mutation."
    reaction: ReactionInput!
}

"All input for the create `Role` mutation."
input CreateRoleInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Role` to be created by this mutation."
    role: RoleInput!
}

"All input for the create `Scheme` mutation."
input CreateSchemeInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Scheme` to be created by this mutation."
    scheme: SchemeInput!
}

"All input for the create `Session` mutation."
input CreateSessionInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Session` to be created by this mutation."
    session: SessionInput!
}

"All input for the create `Status` mutation."
input CreateStatusInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Status` to be created by this mutation."
    status: StatusInput!
}

"All input for the create `System` mutation."
input CreateSystemInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `System` to be created by this mutation."
    system: SystemInput!
}

"All input for the create `Team` mutation."
input CreateTeamInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Team` to be created by this mutation."
    team: TeamInput!
}

"All input for the create `Teammember` mutation."
input CreateTeammemberInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Teammember` to be created by this mutation."
    teammember: TeammemberInput!
}

"All input for the create `Termsofservice` mutation."
input CreateTermsofserviceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Termsofservice` to be created by this mutation."
    termsofservice: TermsofserviceInput!
}

"All input for the create `Token` mutation."
input CreateTokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Token` to be created by this mutation."
    token: TokenInput!
}

"All input for the create `User` mutation."
input CreateUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `User` to be created by this mutation."
    user: UserInput!
}

"All input for the create `Useraccesstoken` mutation."
input CreateUseraccesstokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Useraccesstoken` to be created by this mutation."
    useraccesstoken: UseraccesstokenInput!
}

"All input for the create `Usergroup` mutation."
input CreateUsergroupInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Usergroup` to be created by this mutation."
    usergroup: UsergroupInput!
}

"All input for the create `Usertermsofservice` mutation."
input CreateUsertermsofserviceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Usertermsofservice` to be created by this mutation."
    usertermsofservice: UsertermsofserviceInput!
}

"All input for the `deleteAuditByNodeId` mutation."
input DeleteAuditByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Audit` to be deleted."
    nodeId: ID!
}

"All input for the `deleteAudit` mutation."
input DeleteAuditInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteBotByNodeId` mutation."
input DeleteBotByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Bot` to be deleted."
    nodeId: ID!
}

"All input for the `deleteBot` mutation."
input DeleteBotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    userid: String!
}

"All input for the `deleteChannelByNameAndTeamid` mutation."
input DeleteChannelByNameAndTeamidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    teamid: String!
}

"All input for the `deleteChannelByNodeId` mutation."
input DeleteChannelByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Channel` to be deleted."
    nodeId: ID!
}

"All input for the `deleteChannel` mutation."
input DeleteChannelInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteChannelmemberByNodeId` mutation."
input DeleteChannelmemberByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Channelmember` to be deleted."
    nodeId: ID!
}

"All input for the `deleteChannelmember` mutation."
input DeleteChannelmemberInput {
    channelid: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    userid: String!
}

"All input for the `deleteChannelmemberhistoryByNodeId` mutation."
input DeleteChannelmemberhistoryByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Channelmemberhistory` to be deleted."
    nodeId: ID!
}

"All input for the `deleteChannelmemberhistory` mutation."
input DeleteChannelmemberhistoryInput {
    channelid: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    jointime: BigInt!
    userid: String!
}

"All input for the `deleteClusterdiscoveryByNodeId` mutation."
input DeleteClusterdiscoveryByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Clusterdiscovery` to be deleted."
    nodeId: ID!
}

"All input for the `deleteClusterdiscovery` mutation."
input DeleteClusterdiscoveryInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteCommandByNodeId` mutation."
input DeleteCommandByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Command` to be deleted."
    nodeId: ID!
}

"All input for the `deleteCommand` mutation."
input DeleteCommandInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteCommandwebhookByNodeId` mutation."
input DeleteCommandwebhookByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Commandwebhook` to be deleted."
    nodeId: ID!
}

"All input for the `deleteCommandwebhook` mutation."
input DeleteCommandwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteComplianceByNodeId` mutation."
input DeleteComplianceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Compliance` to be deleted."
    nodeId: ID!
}

"All input for the `deleteCompliance` mutation."
input DeleteComplianceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteEmojiByNameAndDeleteat` mutation."
input DeleteEmojiByNameAndDeleteatInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    deleteat: BigInt!
    name: String!
}

"All input for the `deleteEmojiByNodeId` mutation."
input DeleteEmojiByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Emoji` to be deleted."
    nodeId: ID!
}

"All input for the `deleteEmoji` mutation."
input DeleteEmojiInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteFileinfoByNodeId` mutation."
input DeleteFileinfoByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Fileinfo` to be deleted."
    nodeId: ID!
}

"All input for the `deleteFileinfo` mutation."
input DeleteFileinfoInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteGroupchannelByNodeId` mutation."
input DeleteGroupchannelByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Groupchannel` to be deleted."
    nodeId: ID!
}

"All input for the `deleteGroupchannel` mutation."
input DeleteGroupchannelInput {
    channelid: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    groupid: String!
}

"All input for the `deleteGroupmemberByNodeId` mutation."
input DeleteGroupmemberByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Groupmember` to be deleted."
    nodeId: ID!
}

"All input for the `deleteGroupmember` mutation."
input DeleteGroupmemberInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    groupid: String!
    userid: String!
}

"All input for the `deleteGroupteamByNodeId` mutation."
input DeleteGroupteamByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Groupteam` to be deleted."
    nodeId: ID!
}

"All input for the `deleteGroupteam` mutation."
input DeleteGroupteamInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    groupid: String!
    teamid: String!
}

"All input for the `deleteIncomingwebhookByNodeId` mutation."
input DeleteIncomingwebhookByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Incomingwebhook` to be deleted."
    nodeId: ID!
}

"All input for the `deleteIncomingwebhook` mutation."
input DeleteIncomingwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteJobByNodeId` mutation."
input DeleteJobByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Job` to be deleted."
    nodeId: ID!
}

"All input for the `deleteJob` mutation."
input DeleteJobInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteLicenseByNodeId` mutation."
input DeleteLicenseByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `License` to be deleted."
    nodeId: ID!
}

"All input for the `deleteLicense` mutation."
input DeleteLicenseInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteLinkmetadatumByNodeId` mutation."
input DeleteLinkmetadatumByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Linkmetadatum` to be deleted."
    nodeId: ID!
}

"All input for the `deleteLinkmetadatum` mutation."
input DeleteLinkmetadatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    hash: BigInt!
}

"All input for the `deleteOauthaccessdatumByClientidAndUserid` mutation."
input DeleteOauthaccessdatumByClientidAndUseridInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    clientid: String!
    userid: String!
}

"All input for the `deleteOauthaccessdatumByNodeId` mutation."
input DeleteOauthaccessdatumByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Oauthaccessdatum` to be deleted."
    nodeId: ID!
}

"All input for the `deleteOauthaccessdatum` mutation."
input DeleteOauthaccessdatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    token: String!
}

"All input for the `deleteOauthappByNodeId` mutation."
input DeleteOauthappByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Oauthapp` to be deleted."
    nodeId: ID!
}

"All input for the `deleteOauthapp` mutation."
input DeleteOauthappInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteOauthauthdatumByNodeId` mutation."
input DeleteOauthauthdatumByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Oauthauthdatum` to be deleted."
    nodeId: ID!
}

"All input for the `deleteOauthauthdatum` mutation."
input DeleteOauthauthdatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    code: String!
}

"All input for the `deleteOutgoingwebhookByNodeId` mutation."
input DeleteOutgoingwebhookByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Outgoingwebhook` to be deleted."
    nodeId: ID!
}

"All input for the `deleteOutgoingwebhook` mutation."
input DeleteOutgoingwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deletePluginkeyvaluestoreByNodeId` mutation."
input DeletePluginkeyvaluestoreByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Pluginkeyvaluestore` to be deleted."
    nodeId: ID!
}

"All input for the `deletePluginkeyvaluestore` mutation."
input DeletePluginkeyvaluestoreInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    pkey: String!
    pluginid: String!
}

"All input for the `deletePostByNodeId` mutation."
input DeletePostByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Post` to be deleted."
    nodeId: ID!
}

"All input for the `deletePost` mutation."
input DeletePostInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deletePreferenceByNodeId` mutation."
input DeletePreferenceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Preference` to be deleted."
    nodeId: ID!
}

"All input for the `deletePreference` mutation."
input DeletePreferenceInput {
    category: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    userid: String!
}

"All input for the `deletePublicchannelByNameAndTeamid` mutation."
input DeletePublicchannelByNameAndTeamidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    teamid: String!
}

"All input for the `deletePublicchannelByNodeId` mutation."
input DeletePublicchannelByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Publicchannel` to be deleted."
    nodeId: ID!
}

"All input for the `deletePublicchannel` mutation."
input DeletePublicchannelInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteReactionByNodeId` mutation."
input DeleteReactionByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Reaction` to be deleted."
    nodeId: ID!
}

"All input for the `deleteReaction` mutation."
input DeleteReactionInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    emojiname: String!
    postid: String!
    userid: String!
}

"All input for the `deleteRoleByName` mutation."
input DeleteRoleByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
}

"All input for the `deleteRoleByNodeId` mutation."
input DeleteRoleByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Role` to be deleted."
    nodeId: ID!
}

"All input for the `deleteRole` mutation."
input DeleteRoleInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteSchemeByName` mutation."
input DeleteSchemeByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
}

"All input for the `deleteSchemeByNodeId` mutation."
input DeleteSchemeByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Scheme` to be deleted."
    nodeId: ID!
}

"All input for the `deleteScheme` mutation."
input DeleteSchemeInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteSessionByNodeId` mutation."
input DeleteSessionByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Session` to be deleted."
    nodeId: ID!
}

"All input for the `deleteSession` mutation."
input DeleteSessionInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteStatusByNodeId` mutation."
input DeleteStatusByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Status` to be deleted."
    nodeId: ID!
}

"All input for the `deleteStatus` mutation."
input DeleteStatusInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    userid: String!
}

"All input for the `deleteSystemByNodeId` mutation."
input DeleteSystemByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `System` to be deleted."
    nodeId: ID!
}

"All input for the `deleteSystem` mutation."
input DeleteSystemInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
}

"All input for the `deleteTeamByName` mutation."
input DeleteTeamByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
}

"All input for the `deleteTeamByNodeId` mutation."
input DeleteTeamByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Team` to be deleted."
    nodeId: ID!
}

"All input for the `deleteTeam` mutation."
input DeleteTeamInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteTeammemberByNodeId` mutation."
input DeleteTeammemberByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Teammember` to be deleted."
    nodeId: ID!
}

"All input for the `deleteTeammember` mutation."
input DeleteTeammemberInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    teamid: String!
    userid: String!
}

"All input for the `deleteTermsofserviceByNodeId` mutation."
input DeleteTermsofserviceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Termsofservice` to be deleted."
    nodeId: ID!
}

"All input for the `deleteTermsofservice` mutation."
input DeleteTermsofserviceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteTokenByNodeId` mutation."
input DeleteTokenByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Token` to be deleted."
    nodeId: ID!
}

"All input for the `deleteToken` mutation."
input DeleteTokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    token: String!
}

"All input for the `deleteUserByAuthdata` mutation."
input DeleteUserByAuthdataInput {
    authdata: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

"All input for the `deleteUserByEmail` mutation."
input DeleteUserByEmailInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    email: String!
}

"All input for the `deleteUserByNodeId` mutation."
input DeleteUserByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `User` to be deleted."
    nodeId: ID!
}

"All input for the `deleteUserByUsername` mutation."
input DeleteUserByUsernameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    username: String!
}

"All input for the `deleteUser` mutation."
input DeleteUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteUseraccesstokenByNodeId` mutation."
input DeleteUseraccesstokenByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Useraccesstoken` to be deleted."
    nodeId: ID!
}

"All input for the `deleteUseraccesstokenByToken` mutation."
input DeleteUseraccesstokenByTokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    token: String!
}

"All input for the `deleteUseraccesstoken` mutation."
input DeleteUseraccesstokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteUsergroupByName` mutation."
input DeleteUsergroupByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
}

"All input for the `deleteUsergroupByNodeId` mutation."
input DeleteUsergroupByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Usergroup` to be deleted."
    nodeId: ID!
}

"All input for the `deleteUsergroupBySourceAndRemoteid` mutation."
input DeleteUsergroupBySourceAndRemoteidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    remoteid: String!
    source: String!
}

"All input for the `deleteUsergroup` mutation."
input DeleteUsergroupInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteUsertermsofserviceByNodeId` mutation."
input DeleteUsertermsofserviceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Usertermsofservice` to be deleted."
    nodeId: ID!
}

"All input for the `deleteUsertermsofservice` mutation."
input DeleteUsertermsofserviceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    userid: String!
}

"A condition to be used against `Emoji` object types. All fields are tested for equality and combined with a logical and."
input EmojiCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `creatorid` field."
    creatorid: String
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Emoji`"
input EmojiInput {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    id: String!
    name: String
    updateat: BigInt
}

"Represents an update to a `Emoji`. Fields that are set will be updated."
input EmojiPatch {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    id: String
    name: String
    updateat: BigInt
}

"A condition to be used against `Fileinfo` object types. All fields are tested for equality and combined with a logical and."
input FileinfoCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `creatorid` field."
    creatorid: String
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `extension` field."
    extension: String
    "Checks for equality with the objects `haspreviewimage` field."
    haspreviewimage: Boolean
    "Checks for equality with the objects `height` field."
    height: Int
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `mimetype` field."
    mimetype: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `path` field."
    path: String
    "Checks for equality with the objects `postid` field."
    postid: String
    "Checks for equality with the objects `previewpath` field."
    previewpath: String
    "Checks for equality with the objects `size` field."
    size: BigInt
    "Checks for equality with the objects `thumbnailpath` field."
    thumbnailpath: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `width` field."
    width: Int
}

"An input for mutations affecting `Fileinfo`"
input FileinfoInput {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    extension: String
    haspreviewimage: Boolean
    height: Int
    id: String!
    mimetype: String
    name: String
    path: String
    postid: String
    previewpath: String
    size: BigInt
    thumbnailpath: String
    updateat: BigInt
    width: Int
}

"Represents an update to a `Fileinfo`. Fields that are set will be updated."
input FileinfoPatch {
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    extension: String
    haspreviewimage: Boolean
    height: Int
    id: String
    mimetype: String
    name: String
    path: String
    postid: String
    previewpath: String
    size: BigInt
    thumbnailpath: String
    updateat: BigInt
    width: Int
}

"A condition to be used against `Groupchannel` object types. All fields are tested for equality and combined with a logical and."
input GroupchannelCondition {
    "Checks for equality with the objects `autoadd` field."
    autoadd: Boolean
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `groupid` field."
    groupid: String
    "Checks for equality with the objects `schemeadmin` field."
    schemeadmin: Boolean
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Groupchannel`"
input GroupchannelInput {
    autoadd: Boolean
    channelid: String!
    createat: BigInt
    deleteat: BigInt
    groupid: String!
    schemeadmin: Boolean
    updateat: BigInt
}

"Represents an update to a `Groupchannel`. Fields that are set will be updated."
input GroupchannelPatch {
    autoadd: Boolean
    channelid: String
    createat: BigInt
    deleteat: BigInt
    groupid: String
    schemeadmin: Boolean
    updateat: BigInt
}

"A condition to be used against `Groupmember` object types. All fields are tested for equality and combined with a logical and."
input GroupmemberCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `groupid` field."
    groupid: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Groupmember`"
input GroupmemberInput {
    createat: BigInt
    deleteat: BigInt
    groupid: String!
    userid: String!
}

"Represents an update to a `Groupmember`. Fields that are set will be updated."
input GroupmemberPatch {
    createat: BigInt
    deleteat: BigInt
    groupid: String
    userid: String
}

"A condition to be used against `Groupteam` object types. All fields are tested for equality and combined with a logical and."
input GroupteamCondition {
    "Checks for equality with the objects `autoadd` field."
    autoadd: Boolean
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `groupid` field."
    groupid: String
    "Checks for equality with the objects `schemeadmin` field."
    schemeadmin: Boolean
    "Checks for equality with the objects `teamid` field."
    teamid: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Groupteam`"
input GroupteamInput {
    autoadd: Boolean
    createat: BigInt
    deleteat: BigInt
    groupid: String!
    schemeadmin: Boolean
    teamid: String!
    updateat: BigInt
}

"Represents an update to a `Groupteam`. Fields that are set will be updated."
input GroupteamPatch {
    autoadd: Boolean
    createat: BigInt
    deleteat: BigInt
    groupid: String
    schemeadmin: Boolean
    teamid: String
    updateat: BigInt
}

"A condition to be used against `Incomingwebhook` object types. All fields are tested for equality and combined with a logical and."
input IncomingwebhookCondition {
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `channellocked` field."
    channellocked: Boolean
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `iconurl` field."
    iconurl: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `teamid` field."
    teamid: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `userid` field."
    userid: String
    "Checks for equality with the objects `username` field."
    username: String
}

"An input for mutations affecting `Incomingwebhook`"
input IncomingwebhookInput {
    channelid: String
    channellocked: Boolean
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String!
    teamid: String
    updateat: BigInt
    userid: String
    username: String
}

"Represents an update to a `Incomingwebhook`. Fields that are set will be updated."
input IncomingwebhookPatch {
    channelid: String
    channellocked: Boolean
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String
    teamid: String
    updateat: BigInt
    userid: String
    username: String
}

"A condition to be used against `Job` object types. All fields are tested for equality and combined with a logical and."
input JobCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `data` field."
    data: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `lastactivityat` field."
    lastactivityat: BigInt
    "Checks for equality with the objects `priority` field."
    priority: BigInt
    "Checks for equality with the objects `progress` field."
    progress: BigInt
    "Checks for equality with the objects `startat` field."
    startat: BigInt
    "Checks for equality with the objects `status` field."
    status: String
    "Checks for equality with the objects `type` field."
    type: String
}

"An input for mutations affecting `Job`"
input JobInput {
    createat: BigInt
    data: String
    id: String!
    lastactivityat: BigInt
    priority: BigInt
    progress: BigInt
    startat: BigInt
    status: String
    type: String
}

"Represents an update to a `Job`. Fields that are set will be updated."
input JobPatch {
    createat: BigInt
    data: String
    id: String
    lastactivityat: BigInt
    priority: BigInt
    progress: BigInt
    startat: BigInt
    status: String
    type: String
}

"A condition to be used against `License` object types. All fields are tested for equality and combined with a logical and."
input LicenseCondition {
    "Checks for equality with the objects `bytes` field."
    bytes: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `id` field."
    id: String
}

"An input for mutations affecting `License`"
input LicenseInput {
    bytes: String
    createat: BigInt
    id: String!
}

"Represents an update to a `License`. Fields that are set will be updated."
input LicensePatch {
    bytes: String
    createat: BigInt
    id: String
}

"A condition to be used against `Linkmetadatum` object types. All fields are tested for equality and combined with a logical and."
input LinkmetadatumCondition {
    "Checks for equality with the objects `data` field."
    data: String
    "Checks for equality with the objects `hash` field."
    hash: BigInt
    "Checks for equality with the objects `timestamp` field."
    timestamp: BigInt
    "Checks for equality with the objects `type` field."
    type: String
    "Checks for equality with the objects `url` field."
    url: String
}

"An input for mutations affecting `Linkmetadatum`"
input LinkmetadatumInput {
    data: String
    hash: BigInt!
    timestamp: BigInt
    type: String
    url: String
}

"Represents an update to a `Linkmetadatum`. Fields that are set will be updated."
input LinkmetadatumPatch {
    data: String
    hash: BigInt
    timestamp: BigInt
    type: String
    url: String
}

"A condition to be used against `Oauthaccessdatum` object types. All fields are tested for equality and combined with a logical and."
input OauthaccessdatumCondition {
    "Checks for equality with the objects `clientid` field."
    clientid: String
    "Checks for equality with the objects `expiresat` field."
    expiresat: BigInt
    "Checks for equality with the objects `redirecturi` field."
    redirecturi: String
    "Checks for equality with the objects `refreshtoken` field."
    refreshtoken: String
    "Checks for equality with the objects `scope` field."
    scope: String
    "Checks for equality with the objects `token` field."
    token: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Oauthaccessdatum`"
input OauthaccessdatumInput {
    clientid: String
    expiresat: BigInt
    redirecturi: String
    refreshtoken: String
    scope: String
    token: String!
    userid: String
}

"Represents an update to a `Oauthaccessdatum`. Fields that are set will be updated."
input OauthaccessdatumPatch {
    clientid: String
    expiresat: BigInt
    redirecturi: String
    refreshtoken: String
    scope: String
    token: String
    userid: String
}

"A condition to be used against `Oauthapp` object types. All fields are tested for equality and combined with a logical and."
input OauthappCondition {
    "Checks for equality with the objects `callbackurls` field."
    callbackurls: String
    "Checks for equality with the objects `clientsecret` field."
    clientsecret: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `creatorid` field."
    creatorid: String
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `homepage` field."
    homepage: String
    "Checks for equality with the objects `iconurl` field."
    iconurl: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `istrusted` field."
    istrusted: Boolean
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Oauthapp`"
input OauthappInput {
    callbackurls: String
    clientsecret: String
    createat: BigInt
    creatorid: String
    description: String
    homepage: String
    iconurl: String
    id: String!
    istrusted: Boolean
    name: String
    updateat: BigInt
}

"Represents an update to a `Oauthapp`. Fields that are set will be updated."
input OauthappPatch {
    callbackurls: String
    clientsecret: String
    createat: BigInt
    creatorid: String
    description: String
    homepage: String
    iconurl: String
    id: String
    istrusted: Boolean
    name: String
    updateat: BigInt
}

"A condition to be used against `Oauthauthdatum` object types. All fields are tested for equality and combined with a logical and."
input OauthauthdatumCondition {
    "Checks for equality with the objects `clientid` field."
    clientid: String
    "Checks for equality with the objects `code` field."
    code: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `expiresin` field."
    expiresin: Int
    "Checks for equality with the objects `redirecturi` field."
    redirecturi: String
    "Checks for equality with the objects `scope` field."
    scope: String
    "Checks for equality with the objects `state` field."
    state: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Oauthauthdatum`"
input OauthauthdatumInput {
    clientid: String
    code: String!
    createat: BigInt
    expiresin: Int
    redirecturi: String
    scope: String
    state: String
    userid: String
}

"Represents an update to a `Oauthauthdatum`. Fields that are set will be updated."
input OauthauthdatumPatch {
    clientid: String
    code: String
    createat: BigInt
    expiresin: Int
    redirecturi: String
    scope: String
    state: String
    userid: String
}

"A condition to be used against `Outgoingwebhook` object types. All fields are tested for equality and combined with a logical and."
input OutgoingwebhookCondition {
    "Checks for equality with the objects `callbackurls` field."
    callbackurls: String
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `contenttype` field."
    contenttype: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `creatorid` field."
    creatorid: String
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `iconurl` field."
    iconurl: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `teamid` field."
    teamid: String
    "Checks for equality with the objects `token` field."
    token: String
    "Checks for equality with the objects `triggerwhen` field."
    triggerwhen: Int
    "Checks for equality with the objects `triggerwords` field."
    triggerwords: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `username` field."
    username: String
}

"An input for mutations affecting `Outgoingwebhook`"
input OutgoingwebhookInput {
    callbackurls: String
    channelid: String
    contenttype: String
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String!
    teamid: String
    token: String
    triggerwhen: Int
    triggerwords: String
    updateat: BigInt
    username: String
}

"Represents an update to a `Outgoingwebhook`. Fields that are set will be updated."
input OutgoingwebhookPatch {
    callbackurls: String
    channelid: String
    contenttype: String
    createat: BigInt
    creatorid: String
    deleteat: BigInt
    description: String
    displayname: String
    iconurl: String
    id: String
    teamid: String
    token: String
    triggerwhen: Int
    triggerwords: String
    updateat: BigInt
    username: String
}

"A condition to be used against `Pluginkeyvaluestore` object types. All fields are tested for equality and combined with a logical and."
input PluginkeyvaluestoreCondition {
    "Checks for equality with the objects `expireat` field."
    expireat: BigInt
    "Checks for equality with the objects `pkey` field."
    pkey: String
    "Checks for equality with the objects `pluginid` field."
    pluginid: String
    "Checks for equality with the objects `pvalue` field."
    pvalue: String
}

"An input for mutations affecting `Pluginkeyvaluestore`"
input PluginkeyvaluestoreInput {
    expireat: BigInt
    pkey: String!
    pluginid: String!
    pvalue: String
}

"Represents an update to a `Pluginkeyvaluestore`. Fields that are set will be updated."
input PluginkeyvaluestorePatch {
    expireat: BigInt
    pkey: String
    pluginid: String
    pvalue: String
}

"A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical and."
input PostCondition {
    "Checks for equality with the objects `channelid` field."
    channelid: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `editat` field."
    editat: BigInt
    "Checks for equality with the objects `fileids` field."
    fileids: String
    "Checks for equality with the objects `filenames` field."
    filenames: String
    "Checks for equality with the objects `hashtags` field."
    hashtags: String
    "Checks for equality with the objects `hasreactions` field."
    hasreactions: Boolean
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `ispinned` field."
    ispinned: Boolean
    "Checks for equality with the objects `message` field."
    message: String
    "Checks for equality with the objects `originalid` field."
    originalid: String
    "Checks for equality with the objects `parentid` field."
    parentid: String
    "Checks for equality with the objects `props` field."
    props: String
    "Checks for equality with the objects `rootid` field."
    rootid: String
    "Checks for equality with the objects `type` field."
    type: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `userId` field."
    userId: String
}

"An input for mutations affecting `Post`"
input PostInput {
    channelid: String
    createat: BigInt
    deleteat: BigInt
    editat: BigInt
    fileids: String
    filenames: String
    hashtags: String
    hasreactions: Boolean
    id: String!
    ispinned: Boolean
    message: String
    originalid: String
    parentid: String
    props: String
    rootid: String
    type: String
    updateat: BigInt
    userId: String
}

"Represents an update to a `Post`. Fields that are set will be updated."
input PostPatch {
    channelid: String
    createat: BigInt
    deleteat: BigInt
    editat: BigInt
    fileids: String
    filenames: String
    hashtags: String
    hasreactions: Boolean
    id: String
    ispinned: Boolean
    message: String
    originalid: String
    parentid: String
    props: String
    rootid: String
    type: String
    updateat: BigInt
    userId: String
}

"A condition to be used against `Preference` object types. All fields are tested for equality and combined with a logical and."
input PreferenceCondition {
    "Checks for equality with the objects `category` field."
    category: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `userid` field."
    userid: String
    "Checks for equality with the objects `value` field."
    value: String
}

"An input for mutations affecting `Preference`"
input PreferenceInput {
    category: String!
    name: String!
    userid: String!
    value: String
}

"Represents an update to a `Preference`. Fields that are set will be updated."
input PreferencePatch {
    category: String
    name: String
    userid: String
    value: String
}

"A condition to be used against `Publicchannel` object types. All fields are tested for equality and combined with a logical and."
input PublicchannelCondition {
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `header` field."
    header: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `purpose` field."
    purpose: String
    "Checks for equality with the objects `teamid` field."
    teamid: String
}

"An input for mutations affecting `Publicchannel`"
input PublicchannelInput {
    deleteat: BigInt
    displayname: String
    header: String
    id: String!
    name: String
    purpose: String
    teamid: String
}

"Represents an update to a `Publicchannel`. Fields that are set will be updated."
input PublicchannelPatch {
    deleteat: BigInt
    displayname: String
    header: String
    id: String
    name: String
    purpose: String
    teamid: String
}

"A condition to be used against `Reaction` object types. All fields are tested for equality and combined with a logical and."
input ReactionCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `emojiname` field."
    emojiname: String
    "Checks for equality with the objects `postid` field."
    postid: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Reaction`"
input ReactionInput {
    createat: BigInt
    emojiname: String!
    postid: String!
    userid: String!
}

"Represents an update to a `Reaction`. Fields that are set will be updated."
input ReactionPatch {
    createat: BigInt
    emojiname: String
    postid: String
    userid: String
}

"A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical and."
input RoleCondition {
    "Checks for equality with the objects `builtin` field."
    builtin: Boolean
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `permissions` field."
    permissions: String
    "Checks for equality with the objects `schememanaged` field."
    schememanaged: Boolean
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Role`"
input RoleInput {
    builtin: Boolean
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    id: String!
    name: String
    permissions: String
    schememanaged: Boolean
    updateat: BigInt
}

"Represents an update to a `Role`. Fields that are set will be updated."
input RolePatch {
    builtin: Boolean
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    id: String
    name: String
    permissions: String
    schememanaged: Boolean
    updateat: BigInt
}

"A condition to be used against `Scheme` object types. All fields are tested for equality and combined with a logical and."
input SchemeCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `defaultchanneladminrole` field."
    defaultchanneladminrole: String
    "Checks for equality with the objects `defaultchannelguestrole` field."
    defaultchannelguestrole: String
    "Checks for equality with the objects `defaultchanneluserrole` field."
    defaultchanneluserrole: String
    "Checks for equality with the objects `defaultteamadminrole` field."
    defaultteamadminrole: String
    "Checks for equality with the objects `defaultteamguestrole` field."
    defaultteamguestrole: String
    "Checks for equality with the objects `defaultteamuserrole` field."
    defaultteamuserrole: String
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `scope` field."
    scope: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Scheme`"
input SchemeInput {
    createat: BigInt
    defaultchanneladminrole: String
    defaultchannelguestrole: String
    defaultchanneluserrole: String
    defaultteamadminrole: String
    defaultteamguestrole: String
    defaultteamuserrole: String
    deleteat: BigInt
    description: String
    displayname: String
    id: String!
    name: String
    scope: String
    updateat: BigInt
}

"Represents an update to a `Scheme`. Fields that are set will be updated."
input SchemePatch {
    createat: BigInt
    defaultchanneladminrole: String
    defaultchannelguestrole: String
    defaultchanneluserrole: String
    defaultteamadminrole: String
    defaultteamguestrole: String
    defaultteamuserrole: String
    deleteat: BigInt
    description: String
    displayname: String
    id: String
    name: String
    scope: String
    updateat: BigInt
}

"A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical and."
input SessionCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deviceid` field."
    deviceid: String
    "Checks for equality with the objects `expiresat` field."
    expiresat: BigInt
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `isoauth` field."
    isoauth: Boolean
    "Checks for equality with the objects `lastactivityat` field."
    lastactivityat: BigInt
    "Checks for equality with the objects `props` field."
    props: String
    "Checks for equality with the objects `roles` field."
    roles: String
    "Checks for equality with the objects `token` field."
    token: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Session`"
input SessionInput {
    createat: BigInt
    deviceid: String
    expiresat: BigInt
    id: String!
    isoauth: Boolean
    lastactivityat: BigInt
    props: String
    roles: String
    token: String
    userid: String
}

"Represents an update to a `Session`. Fields that are set will be updated."
input SessionPatch {
    createat: BigInt
    deviceid: String
    expiresat: BigInt
    id: String
    isoauth: Boolean
    lastactivityat: BigInt
    props: String
    roles: String
    token: String
    userid: String
}

"A condition to be used against `Status` object types. All fields are tested for equality and combined with a logical and."
input StatusCondition {
    "Checks for equality with the objects `lastactivityat` field."
    lastactivityat: BigInt
    "Checks for equality with the objects `manual` field."
    manual: Boolean
    "Checks for equality with the objects `status` field."
    status: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Status`"
input StatusInput {
    lastactivityat: BigInt
    manual: Boolean
    status: String
    userid: String!
}

"Represents an update to a `Status`. Fields that are set will be updated."
input StatusPatch {
    lastactivityat: BigInt
    manual: Boolean
    status: String
    userid: String
}

"A condition to be used against `System` object types. All fields are tested for equality and combined with a logical and."
input SystemCondition {
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `value` field."
    value: String
}

"An input for mutations affecting `System`"
input SystemInput {
    name: String!
    value: String
}

"Represents an update to a `System`. Fields that are set will be updated."
input SystemPatch {
    name: String
    value: String
}

"A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical and."
input TeamCondition {
    "Checks for equality with the objects `alloweddomains` field."
    alloweddomains: String
    "Checks for equality with the objects `allowopeninvite` field."
    allowopeninvite: Boolean
    "Checks for equality with the objects `companyname` field."
    companyname: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `email` field."
    email: String
    "Checks for equality with the objects `groupconstrained` field."
    groupconstrained: Boolean
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `inviteid` field."
    inviteid: String
    "Checks for equality with the objects `lastteamiconupdate` field."
    lastteamiconupdate: BigInt
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `schemeid` field."
    schemeid: String
    "Checks for equality with the objects `type` field."
    type: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Team`"
input TeamInput {
    alloweddomains: String
    allowopeninvite: Boolean
    companyname: String
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    email: String
    groupconstrained: Boolean
    id: String!
    inviteid: String
    lastteamiconupdate: BigInt
    name: String
    schemeid: String
    type: String
    updateat: BigInt
}

"Represents an update to a `Team`. Fields that are set will be updated."
input TeamPatch {
    alloweddomains: String
    allowopeninvite: Boolean
    companyname: String
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    email: String
    groupconstrained: Boolean
    id: String
    inviteid: String
    lastteamiconupdate: BigInt
    name: String
    schemeid: String
    type: String
    updateat: BigInt
}

"A condition to be used against `Teammember` object types. All fields are tested for equality and combined with a logical and."
input TeammemberCondition {
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `roles` field."
    roles: String
    "Checks for equality with the objects `schemeadmin` field."
    schemeadmin: Boolean
    "Checks for equality with the objects `schemeguest` field."
    schemeguest: Boolean
    "Checks for equality with the objects `schemeuser` field."
    schemeuser: Boolean
    "Checks for equality with the objects `teamid` field."
    teamid: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Teammember`"
input TeammemberInput {
    deleteat: BigInt
    roles: String
    schemeadmin: Boolean
    schemeguest: Boolean
    schemeuser: Boolean
    teamid: String!
    userid: String!
}

"Represents an update to a `Teammember`. Fields that are set will be updated."
input TeammemberPatch {
    deleteat: BigInt
    roles: String
    schemeadmin: Boolean
    schemeguest: Boolean
    schemeuser: Boolean
    teamid: String
    userid: String
}

"A condition to be used against `Termsofservice` object types. All fields are tested for equality and combined with a logical and."
input TermsofserviceCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `text` field."
    text: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Termsofservice`"
input TermsofserviceInput {
    createat: BigInt
    id: String!
    text: String
    userid: String
}

"Represents an update to a `Termsofservice`. Fields that are set will be updated."
input TermsofservicePatch {
    createat: BigInt
    id: String
    text: String
    userid: String
}

"A condition to be used against `Token` object types. All fields are tested for equality and combined with a logical and."
input TokenCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `extra` field."
    extra: String
    "Checks for equality with the objects `token` field."
    token: String
    "Checks for equality with the objects `type` field."
    type: String
}

"An input for mutations affecting `Token`"
input TokenInput {
    createat: BigInt
    extra: String
    token: String!
    type: String
}

"Represents an update to a `Token`. Fields that are set will be updated."
input TokenPatch {
    createat: BigInt
    extra: String
    token: String
    type: String
}

"All input for the `updateAuditByNodeId` mutation."
input UpdateAuditByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Audit` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Audit` being updated."
    patch: AuditPatch!
}

"All input for the `updateAudit` mutation."
input UpdateAuditInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Audit` being updated."
    patch: AuditPatch!
}

"All input for the `updateBotByNodeId` mutation."
input UpdateBotByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Bot` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Bot` being updated."
    patch: BotPatch!
}

"All input for the `updateBot` mutation."
input UpdateBotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Bot` being updated."
    patch: BotPatch!
    userid: String!
}

"All input for the `updateChannelByNameAndTeamid` mutation."
input UpdateChannelByNameAndTeamidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Channel` being updated."
    patch: ChannelPatch!
    teamid: String!
}

"All input for the `updateChannelByNodeId` mutation."
input UpdateChannelByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Channel` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Channel` being updated."
    patch: ChannelPatch!
}

"All input for the `updateChannel` mutation."
input UpdateChannelInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Channel` being updated."
    patch: ChannelPatch!
}

"All input for the `updateChannelmemberByNodeId` mutation."
input UpdateChannelmemberByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Channelmember` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Channelmember` being updated."
    patch: ChannelmemberPatch!
}

"All input for the `updateChannelmember` mutation."
input UpdateChannelmemberInput {
    channelid: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Channelmember` being updated."
    patch: ChannelmemberPatch!
    userid: String!
}

"All input for the `updateChannelmemberhistoryByNodeId` mutation."
input UpdateChannelmemberhistoryByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Channelmemberhistory` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Channelmemberhistory` being updated."
    patch: ChannelmemberhistoryPatch!
}

"All input for the `updateChannelmemberhistory` mutation."
input UpdateChannelmemberhistoryInput {
    channelid: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    jointime: BigInt!
    "An object where the defined keys will be set on the `Channelmemberhistory` being updated."
    patch: ChannelmemberhistoryPatch!
    userid: String!
}

"All input for the `updateClusterdiscoveryByNodeId` mutation."
input UpdateClusterdiscoveryByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Clusterdiscovery` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Clusterdiscovery` being updated."
    patch: ClusterdiscoveryPatch!
}

"All input for the `updateClusterdiscovery` mutation."
input UpdateClusterdiscoveryInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Clusterdiscovery` being updated."
    patch: ClusterdiscoveryPatch!
}

"All input for the `updateCommandByNodeId` mutation."
input UpdateCommandByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Command` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Command` being updated."
    patch: CommandPatch!
}

"All input for the `updateCommand` mutation."
input UpdateCommandInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Command` being updated."
    patch: CommandPatch!
}

"All input for the `updateCommandwebhookByNodeId` mutation."
input UpdateCommandwebhookByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Commandwebhook` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Commandwebhook` being updated."
    patch: CommandwebhookPatch!
}

"All input for the `updateCommandwebhook` mutation."
input UpdateCommandwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Commandwebhook` being updated."
    patch: CommandwebhookPatch!
}

"All input for the `updateComplianceByNodeId` mutation."
input UpdateComplianceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Compliance` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Compliance` being updated."
    patch: CompliancePatch!
}

"All input for the `updateCompliance` mutation."
input UpdateComplianceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Compliance` being updated."
    patch: CompliancePatch!
}

"All input for the `updateEmojiByNameAndDeleteat` mutation."
input UpdateEmojiByNameAndDeleteatInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    deleteat: BigInt!
    name: String!
    "An object where the defined keys will be set on the `Emoji` being updated."
    patch: EmojiPatch!
}

"All input for the `updateEmojiByNodeId` mutation."
input UpdateEmojiByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Emoji` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Emoji` being updated."
    patch: EmojiPatch!
}

"All input for the `updateEmoji` mutation."
input UpdateEmojiInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Emoji` being updated."
    patch: EmojiPatch!
}

"All input for the `updateFileinfoByNodeId` mutation."
input UpdateFileinfoByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Fileinfo` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Fileinfo` being updated."
    patch: FileinfoPatch!
}

"All input for the `updateFileinfo` mutation."
input UpdateFileinfoInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Fileinfo` being updated."
    patch: FileinfoPatch!
}

"All input for the `updateGroupchannelByNodeId` mutation."
input UpdateGroupchannelByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Groupchannel` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Groupchannel` being updated."
    patch: GroupchannelPatch!
}

"All input for the `updateGroupchannel` mutation."
input UpdateGroupchannelInput {
    channelid: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    groupid: String!
    "An object where the defined keys will be set on the `Groupchannel` being updated."
    patch: GroupchannelPatch!
}

"All input for the `updateGroupmemberByNodeId` mutation."
input UpdateGroupmemberByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Groupmember` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Groupmember` being updated."
    patch: GroupmemberPatch!
}

"All input for the `updateGroupmember` mutation."
input UpdateGroupmemberInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    groupid: String!
    "An object where the defined keys will be set on the `Groupmember` being updated."
    patch: GroupmemberPatch!
    userid: String!
}

"All input for the `updateGroupteamByNodeId` mutation."
input UpdateGroupteamByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Groupteam` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Groupteam` being updated."
    patch: GroupteamPatch!
}

"All input for the `updateGroupteam` mutation."
input UpdateGroupteamInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    groupid: String!
    "An object where the defined keys will be set on the `Groupteam` being updated."
    patch: GroupteamPatch!
    teamid: String!
}

"All input for the `updateIncomingwebhookByNodeId` mutation."
input UpdateIncomingwebhookByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Incomingwebhook` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Incomingwebhook` being updated."
    patch: IncomingwebhookPatch!
}

"All input for the `updateIncomingwebhook` mutation."
input UpdateIncomingwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Incomingwebhook` being updated."
    patch: IncomingwebhookPatch!
}

"All input for the `updateJobByNodeId` mutation."
input UpdateJobByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Job` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Job` being updated."
    patch: JobPatch!
}

"All input for the `updateJob` mutation."
input UpdateJobInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Job` being updated."
    patch: JobPatch!
}

"All input for the `updateLicenseByNodeId` mutation."
input UpdateLicenseByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `License` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `License` being updated."
    patch: LicensePatch!
}

"All input for the `updateLicense` mutation."
input UpdateLicenseInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `License` being updated."
    patch: LicensePatch!
}

"All input for the `updateLinkmetadatumByNodeId` mutation."
input UpdateLinkmetadatumByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Linkmetadatum` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Linkmetadatum` being updated."
    patch: LinkmetadatumPatch!
}

"All input for the `updateLinkmetadatum` mutation."
input UpdateLinkmetadatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    hash: BigInt!
    "An object where the defined keys will be set on the `Linkmetadatum` being updated."
    patch: LinkmetadatumPatch!
}

"All input for the `updateOauthaccessdatumByClientidAndUserid` mutation."
input UpdateOauthaccessdatumByClientidAndUseridInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    clientid: String!
    "An object where the defined keys will be set on the `Oauthaccessdatum` being updated."
    patch: OauthaccessdatumPatch!
    userid: String!
}

"All input for the `updateOauthaccessdatumByNodeId` mutation."
input UpdateOauthaccessdatumByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Oauthaccessdatum` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Oauthaccessdatum` being updated."
    patch: OauthaccessdatumPatch!
}

"All input for the `updateOauthaccessdatum` mutation."
input UpdateOauthaccessdatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Oauthaccessdatum` being updated."
    patch: OauthaccessdatumPatch!
    token: String!
}

"All input for the `updateOauthappByNodeId` mutation."
input UpdateOauthappByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Oauthapp` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Oauthapp` being updated."
    patch: OauthappPatch!
}

"All input for the `updateOauthapp` mutation."
input UpdateOauthappInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Oauthapp` being updated."
    patch: OauthappPatch!
}

"All input for the `updateOauthauthdatumByNodeId` mutation."
input UpdateOauthauthdatumByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Oauthauthdatum` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Oauthauthdatum` being updated."
    patch: OauthauthdatumPatch!
}

"All input for the `updateOauthauthdatum` mutation."
input UpdateOauthauthdatumInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    code: String!
    "An object where the defined keys will be set on the `Oauthauthdatum` being updated."
    patch: OauthauthdatumPatch!
}

"All input for the `updateOutgoingwebhookByNodeId` mutation."
input UpdateOutgoingwebhookByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Outgoingwebhook` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Outgoingwebhook` being updated."
    patch: OutgoingwebhookPatch!
}

"All input for the `updateOutgoingwebhook` mutation."
input UpdateOutgoingwebhookInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Outgoingwebhook` being updated."
    patch: OutgoingwebhookPatch!
}

"All input for the `updatePluginkeyvaluestoreByNodeId` mutation."
input UpdatePluginkeyvaluestoreByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Pluginkeyvaluestore` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Pluginkeyvaluestore` being updated."
    patch: PluginkeyvaluestorePatch!
}

"All input for the `updatePluginkeyvaluestore` mutation."
input UpdatePluginkeyvaluestoreInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Pluginkeyvaluestore` being updated."
    patch: PluginkeyvaluestorePatch!
    pkey: String!
    pluginid: String!
}

"All input for the `updatePostByNodeId` mutation."
input UpdatePostByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Post` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Post` being updated."
    patch: PostPatch!
}

"All input for the `updatePost` mutation."
input UpdatePostInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Post` being updated."
    patch: PostPatch!
}

"All input for the `updatePreferenceByNodeId` mutation."
input UpdatePreferenceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Preference` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Preference` being updated."
    patch: PreferencePatch!
}

"All input for the `updatePreference` mutation."
input UpdatePreferenceInput {
    category: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Preference` being updated."
    patch: PreferencePatch!
    userid: String!
}

"All input for the `updatePublicchannelByNameAndTeamid` mutation."
input UpdatePublicchannelByNameAndTeamidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Publicchannel` being updated."
    patch: PublicchannelPatch!
    teamid: String!
}

"All input for the `updatePublicchannelByNodeId` mutation."
input UpdatePublicchannelByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Publicchannel` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Publicchannel` being updated."
    patch: PublicchannelPatch!
}

"All input for the `updatePublicchannel` mutation."
input UpdatePublicchannelInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Publicchannel` being updated."
    patch: PublicchannelPatch!
}

"All input for the `updateReactionByNodeId` mutation."
input UpdateReactionByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Reaction` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Reaction` being updated."
    patch: ReactionPatch!
}

"All input for the `updateReaction` mutation."
input UpdateReactionInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    emojiname: String!
    "An object where the defined keys will be set on the `Reaction` being updated."
    patch: ReactionPatch!
    postid: String!
    userid: String!
}

"All input for the `updateRoleByName` mutation."
input UpdateRoleByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Role` being updated."
    patch: RolePatch!
}

"All input for the `updateRoleByNodeId` mutation."
input UpdateRoleByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Role` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Role` being updated."
    patch: RolePatch!
}

"All input for the `updateRole` mutation."
input UpdateRoleInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Role` being updated."
    patch: RolePatch!
}

"All input for the `updateSchemeByName` mutation."
input UpdateSchemeByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Scheme` being updated."
    patch: SchemePatch!
}

"All input for the `updateSchemeByNodeId` mutation."
input UpdateSchemeByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Scheme` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Scheme` being updated."
    patch: SchemePatch!
}

"All input for the `updateScheme` mutation."
input UpdateSchemeInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Scheme` being updated."
    patch: SchemePatch!
}

"All input for the `updateSessionByNodeId` mutation."
input UpdateSessionByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Session` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Session` being updated."
    patch: SessionPatch!
}

"All input for the `updateSession` mutation."
input UpdateSessionInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Session` being updated."
    patch: SessionPatch!
}

"All input for the `updateStatusByNodeId` mutation."
input UpdateStatusByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Status` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Status` being updated."
    patch: StatusPatch!
}

"All input for the `updateStatus` mutation."
input UpdateStatusInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Status` being updated."
    patch: StatusPatch!
    userid: String!
}

"All input for the `updateSystemByNodeId` mutation."
input UpdateSystemByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `System` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `System` being updated."
    patch: SystemPatch!
}

"All input for the `updateSystem` mutation."
input UpdateSystemInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `System` being updated."
    patch: SystemPatch!
}

"All input for the `updateTeamByName` mutation."
input UpdateTeamByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Team` being updated."
    patch: TeamPatch!
}

"All input for the `updateTeamByNodeId` mutation."
input UpdateTeamByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Team` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Team` being updated."
    patch: TeamPatch!
}

"All input for the `updateTeam` mutation."
input UpdateTeamInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Team` being updated."
    patch: TeamPatch!
}

"All input for the `updateTeammemberByNodeId` mutation."
input UpdateTeammemberByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Teammember` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Teammember` being updated."
    patch: TeammemberPatch!
}

"All input for the `updateTeammember` mutation."
input UpdateTeammemberInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Teammember` being updated."
    patch: TeammemberPatch!
    teamid: String!
    userid: String!
}

"All input for the `updateTermsofserviceByNodeId` mutation."
input UpdateTermsofserviceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Termsofservice` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Termsofservice` being updated."
    patch: TermsofservicePatch!
}

"All input for the `updateTermsofservice` mutation."
input UpdateTermsofserviceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Termsofservice` being updated."
    patch: TermsofservicePatch!
}

"All input for the `updateTokenByNodeId` mutation."
input UpdateTokenByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Token` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Token` being updated."
    patch: TokenPatch!
}

"All input for the `updateToken` mutation."
input UpdateTokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Token` being updated."
    patch: TokenPatch!
    token: String!
}

"All input for the `updateUserByAuthdata` mutation."
input UpdateUserByAuthdataInput {
    authdata: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `User` being updated."
    patch: UserPatch!
}

"All input for the `updateUserByEmail` mutation."
input UpdateUserByEmailInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    email: String!
    "An object where the defined keys will be set on the `User` being updated."
    patch: UserPatch!
}

"All input for the `updateUserByNodeId` mutation."
input UpdateUserByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `User` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `User` being updated."
    patch: UserPatch!
}

"All input for the `updateUserByUsername` mutation."
input UpdateUserByUsernameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `User` being updated."
    patch: UserPatch!
    username: String!
}

"All input for the `updateUser` mutation."
input UpdateUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `User` being updated."
    patch: UserPatch!
}

"All input for the `updateUseraccesstokenByNodeId` mutation."
input UpdateUseraccesstokenByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Useraccesstoken` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Useraccesstoken` being updated."
    patch: UseraccesstokenPatch!
}

"All input for the `updateUseraccesstokenByToken` mutation."
input UpdateUseraccesstokenByTokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Useraccesstoken` being updated."
    patch: UseraccesstokenPatch!
    token: String!
}

"All input for the `updateUseraccesstoken` mutation."
input UpdateUseraccesstokenInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Useraccesstoken` being updated."
    patch: UseraccesstokenPatch!
}

"All input for the `updateUsergroupByName` mutation."
input UpdateUsergroupByNameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    name: String!
    "An object where the defined keys will be set on the `Usergroup` being updated."
    patch: UsergroupPatch!
}

"All input for the `updateUsergroupByNodeId` mutation."
input UpdateUsergroupByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Usergroup` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Usergroup` being updated."
    patch: UsergroupPatch!
}

"All input for the `updateUsergroupBySourceAndRemoteid` mutation."
input UpdateUsergroupBySourceAndRemoteidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Usergroup` being updated."
    patch: UsergroupPatch!
    remoteid: String!
    source: String!
}

"All input for the `updateUsergroup` mutation."
input UpdateUsergroupInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Usergroup` being updated."
    patch: UsergroupPatch!
}

"All input for the `updateUsertermsofserviceByNodeId` mutation."
input UpdateUsertermsofserviceByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Usertermsofservice` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Usertermsofservice` being updated."
    patch: UsertermsofservicePatch!
}

"All input for the `updateUsertermsofservice` mutation."
input UpdateUsertermsofserviceInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Usertermsofservice` being updated."
    patch: UsertermsofservicePatch!
    userid: String!
}

"A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and."
input UserCondition {
    "Checks for equality with the objects `allowmarketing` field."
    allowmarketing: Boolean
    "Checks for equality with the objects `authdata` field."
    authdata: String
    "Checks for equality with the objects `authservice` field."
    authservice: String
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `email` field."
    email: String
    "Checks for equality with the objects `emailverified` field."
    emailverified: Boolean
    "Checks for equality with the objects `failedattempts` field."
    failedattempts: Int
    "Checks for equality with the objects `firstname` field."
    firstname: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `lastname` field."
    lastname: String
    "Checks for equality with the objects `lastpasswordupdate` field."
    lastpasswordupdate: BigInt
    "Checks for equality with the objects `lastpictureupdate` field."
    lastpictureupdate: BigInt
    "Checks for equality with the objects `locale` field."
    locale: String
    "Checks for equality with the objects `mfaactive` field."
    mfaactive: Boolean
    "Checks for equality with the objects `mfasecret` field."
    mfasecret: String
    "Checks for equality with the objects `nickname` field."
    nickname: String
    "Checks for equality with the objects `notifyprops` field."
    notifyprops: String
    "Checks for equality with the objects `password` field."
    password: String
    "Checks for equality with the objects `position` field."
    position: String
    "Checks for equality with the objects `props` field."
    props: String
    "Checks for equality with the objects `roles` field."
    roles: String
    "Checks for equality with the objects `timezone` field."
    timezone: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
    "Checks for equality with the objects `username` field."
    username: String
}

"An input for mutations affecting `User`"
input UserInput {
    allowmarketing: Boolean
    authdata: String
    authservice: String
    createat: BigInt
    deleteat: BigInt
    email: String
    emailverified: Boolean
    failedattempts: Int
    firstname: String
    id: String!
    lastname: String
    lastpasswordupdate: BigInt
    lastpictureupdate: BigInt
    locale: String
    mfaactive: Boolean
    mfasecret: String
    nickname: String
    notifyprops: String
    password: String
    position: String
    props: String
    roles: String
    timezone: String
    updateat: BigInt
    username: String
}

"Represents an update to a `User`. Fields that are set will be updated."
input UserPatch {
    allowmarketing: Boolean
    authdata: String
    authservice: String
    createat: BigInt
    deleteat: BigInt
    email: String
    emailverified: Boolean
    failedattempts: Int
    firstname: String
    id: String
    lastname: String
    lastpasswordupdate: BigInt
    lastpictureupdate: BigInt
    locale: String
    mfaactive: Boolean
    mfasecret: String
    nickname: String
    notifyprops: String
    password: String
    position: String
    props: String
    roles: String
    timezone: String
    updateat: BigInt
    username: String
}

"A condition to be used against `Useraccesstoken` object types. All fields are tested for equality and combined with a logical and."
input UseraccesstokenCondition {
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `isactive` field."
    isactive: Boolean
    "Checks for equality with the objects `token` field."
    token: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Useraccesstoken`"
input UseraccesstokenInput {
    description: String
    id: String!
    isactive: Boolean
    token: String
    userid: String
}

"Represents an update to a `Useraccesstoken`. Fields that are set will be updated."
input UseraccesstokenPatch {
    description: String
    id: String
    isactive: Boolean
    token: String
    userid: String
}

"A condition to be used against `Usergroup` object types. All fields are tested for equality and combined with a logical and."
input UsergroupCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `deleteat` field."
    deleteat: BigInt
    "Checks for equality with the objects `description` field."
    description: String
    "Checks for equality with the objects `displayname` field."
    displayname: String
    "Checks for equality with the objects `id` field."
    id: String
    "Checks for equality with the objects `name` field."
    name: String
    "Checks for equality with the objects `remoteid` field."
    remoteid: String
    "Checks for equality with the objects `source` field."
    source: String
    "Checks for equality with the objects `updateat` field."
    updateat: BigInt
}

"An input for mutations affecting `Usergroup`"
input UsergroupInput {
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    id: String!
    name: String
    remoteid: String
    source: String
    updateat: BigInt
}

"Represents an update to a `Usergroup`. Fields that are set will be updated."
input UsergroupPatch {
    createat: BigInt
    deleteat: BigInt
    description: String
    displayname: String
    id: String
    name: String
    remoteid: String
    source: String
    updateat: BigInt
}

"A condition to be used against `Usertermsofservice` object types. All fields are tested for equality and combined with a logical and."
input UsertermsofserviceCondition {
    "Checks for equality with the objects `createat` field."
    createat: BigInt
    "Checks for equality with the objects `termsofserviceid` field."
    termsofserviceid: String
    "Checks for equality with the objects `userid` field."
    userid: String
}

"An input for mutations affecting `Usertermsofservice`"
input UsertermsofserviceInput {
    createat: BigInt
    termsofserviceid: String
    userid: String!
}

"Represents an update to a `Usertermsofservice`. Fields that are set will be updated."
input UsertermsofservicePatch {
    createat: BigInt
    termsofserviceid: String
    userid: String
}


"A location in a connection that can be used for resuming pagination."
scalar Cursor

"A signed eight-byte integer. The upper big integer values are greater than the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers."
scalar BigInt
